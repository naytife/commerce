"""
Directs the executor to defer this fragment when the `if` argument is true or undefined.
"""
directive @defer(
  """Deferred when true or undefined."""
  if: Boolean = true

  """Unique name"""
  label: String
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
Indicates exactly one field must be supplied and this field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

type Category implements Node {
  createdAt: DateTime!
  description: String
  id: ID!
  images: CategoryImages
  products(after: ID, first: Int = 20): ProductConnection
  slug: String!
  title: String!
  updatedAt: DateTime!
}

type CategoryConnection {
  edges: [CategoryEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CategoryEdge {
  cursor: String!
  node: Category!
}

type CategoryImages {
  banner: Image!
}

type CategoryNotFoundError implements UserError {
  code: ErrorCode!
  message: String!
  path: [String!]!
}

input CreateOrderInput {
  customerId: ID
  discount: Float = 0
  email: String
  fullName: String
  items: [CreateOrderItemInput!]!
  paymentMethod: PaymentMethodType!
  phoneNumber: String
  shippingAddress: String!
  shippingCost: Float = 0
  shippingMethod: String!
  tax: Float = 0
}

input CreateOrderItemInput {
  price: Float!
  productVariationId: ID!
  quantity: Int!
}

type CreateOrderPayload {
  errors: [UserError!]!
  order: Order
}

scalar DateTime

enum ErrorCode {
  AUTH_INVALID_TOKEN
  NOT_FOUND_CATEGORY
  NOT_FOUND_SHOP
  RATE_LIMIT_EXCEEDED
  SERVER_ERROR_INTERNAL
  VALIDATION_INVALID_INPUT
}

type Image {
  altText: String
  url: String!
}

input ImageInput {
  altText: String
  url: String!
}

type Mutation {
  createOrder(input: CreateOrderInput!): CreateOrderPayload!
  updateOrderStatus(input: UpdateOrderStatusInput!): UpdateOrderStatusPayload!
}

interface Node {
  id: ID!
}

type Order implements Node {
  CustomerId: ID
  amount: Float!
  createdAt: DateTime!
  customerEmail: String
  customerName: String!
  customerPhone: String
  discount: Float!
  id: ID!
  items: [OrderItem!]!
  orderId: Int!
  paymentMethod: PaymentMethodType!
  paymentStatus: PaymentStatusType!
  shippingAddress: String!
  shippingCost: Float!
  shippingMethod: String!
  shippingStatus: ShippingStatusType!
  shopId: ID!
  status: OrderStatusType!
  tax: Float!
  transactionId: String
  updatedAt: DateTime!
  username: String!
}

type OrderConnection {
  edges: [OrderEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type OrderEdge {
  cursor: ID!
  node: Order!
}

type OrderItem implements Node {
  id: ID!
  orderItemId: Int!
  price: Float!
  productVariationId: ID!
  quantity: Int!
}

enum OrderStatusType {
  CANCELLED
  COMPLETED
  PENDING
  PROCESSING
  REFUNDED
}

type PageInfo {
  endCursor: ID!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: ID!
}

type PaymentMethodConfig {
  publishableKey: String
  testMode: Boolean
}

type PaymentMethodInfo {
  config: PaymentMethodConfig!
  enabled: Boolean!
  id: String!
  name: String!
  provider: String!
}

enum PaymentMethodType {
  FLUTTERWAVE
  PAYPAL
  PAYSTACK
  STRIPE
}

enum PaymentStatusType {
  FAILED
  PAID
  PARTIAL_REFUND
  PENDING
  REFUNDED
}

type Product implements Node {
  attributes: [ProductAttribute!]!
  createdAt: DateTime!
  defaultVariant: ProductVariant!
  description: String!
  id: ID!
  images: [Image!]!
  productId: Int!
  slug: String!
  title: String!
  updatedAt: DateTime!
  variants: [ProductVariant!]!
}

type ProductAttribute {
  title: String!
  value: String!
}

type ProductConnection {
  edges: [ProductEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProductEdge {
  cursor: ID!
  node: Product!
}

type ProductNotFoundError implements UserError {
  code: ErrorCode!
  message: String!
  path: [String!]!
}

enum ProductStockStatus {
  IN_STOCK
  OUT_OF_STOCK
  PREORDER
}

type ProductVariant implements Node {
  attributes: [ProductAttribute!]!
  availableQuantity: Int!
  description: String!
  id: ID!
  isDefault: Boolean!
  price: Float!
  stockStatus: ProductStockStatus!
  variationId: Int!
}

type Query {
  categories(after: ID, first: Int = 20): CategoryConnection
  category(id: ID!): Category
  node(id: ID!): Node
  order(id: ID!): Order
  orders(after: ID, first: Int = 20): OrderConnection
  product(id: ID!): Product
  products(after: ID, first: Int = 20): ProductConnection!
  shop: Shop!
}

enum ShippingStatusType {
  CANCELLED
  DELIVERED
  PENDING
  RETURNED
  SHIPPED
}

type Shop implements Node {
  about: String
  address: ShopAddress!
  categories(after: ID, first: Int = 20): CategoryConnection
  contactEmail: String
  contactPhone: String
  currencyCode: String!
  defaultDomain: String!
  facebookLink: String
  id: ID!
  images: ShopImages!
  instagramLink: String
  paymentMethods: [PaymentMethodInfo!]!
  products(after: ID, first: Int = 20): ProductConnection
  seoDescription: String
  seoKeywords: [String!]!
  seoTitle: String
  shopProductsCategory: String
  title: String!
  whatsAppLink: String
  whatsAppNumber: String
}

type ShopAddress {
  address: String!
}

input ShopAddressInput {
  address: String!
}

type ShopImages {
  banner: Image
  bannerDark: Image
  coverImage: Image
  coverImageDark: Image
  favicon: Image
  siteLogo: Image
  siteLogoDark: Image
}

input UpdateOrderStatusInput {
  orderId: ID!
  status: OrderStatusType!
}

type UpdateOrderStatusPayload {
  errors: [UserError!]!
  order: Order
}

interface UserError {
  code: ErrorCode!
  message: String!
  path: [String!]!
}
