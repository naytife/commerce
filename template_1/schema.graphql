"""
The @defer directive may be specified on a fragment spread to imply de-prioritization, that causes the fragment to be omitted in the initial response, and delivered as a subsequent response afterward. A query with @defer directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred delivered in a subsequent response. @include and @skip take precedence over @defer.
"""
directive @defer(if: Boolean = true, label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

type AllowedCategoryAttributes {
  dataType: ProductAttributeDataType!
  title: String!
}

type AllowedProductAttributes {
  dataType: ProductAttributeDataType!
  title: String!
}

type Category implements Node {
  allowedAttributes: [AllowedCategoryAttributes!]!
  createdAt: DateTime!
  description: String
  id: ID!
  images: CategoryImages
  products(after: ID, first: Int = 20): ProductConnection
  slug: String!
  title: String!
  updatedAt: DateTime!
}

type CategoryConnection {
  edges: [CategoryEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CategoryEdge {
  cursor: String!
  node: Category!
}

type CategoryImages {
  banner: Image!
}

type CategoryNotFoundError implements UserError {
  code: ErrorCode!
  message: String!
  path: [String!]!
}

scalar DateTime

enum ErrorCode {
  AUTH_INVALID_TOKEN
  NOT_FOUND_CATEGORY
  NOT_FOUND_SHOP
  RATE_LIMIT_EXCEEDED
  SERVER_ERROR_INTERNAL
  VALIDATION_INVALID_INPUT
}

type Image {
  altText: String
  url: String!
}

input ImageInput {
  altText: String
  url: String!
}

interface Node {
  id: ID!
}

type PageInfo {
  endCursor: ID!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: ID!
}

type Product implements Node {
  createdAt: DateTime!
  defaultVariant: ProductVariant!
  description: String!
  id: ID!
  images: [Image!]!
  title: String!
  updatedAt: DateTime!
  variants: [ProductVariant!]!
}

type ProductAttribute {
  key: String!
  value: String
}

enum ProductAttributeDataType {
  INTEGER
  STRING
}

type ProductAttributeValue {
  intValue: Int
  stringValue: String
}

type ProductConnection {
  edges: [ProductEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProductEdge {
  cursor: ID!
  node: Product!
}

type ProductNotFoundError implements UserError {
  code: ErrorCode!
  message: String!
  path: [String!]!
}

enum ProductStockStatus {
  IN_STOCK
  OUT_OF_STOCK
  PREORDER
}

type ProductVariant implements Node {
  attributes: [ProductAttribute!]!
  availableQuantity: Int!
  createdAt: DateTime!
  description: String!
  id: ID!
  price: Float!
  slug: String!
  stockStatus: ProductStockStatus!
  updatedAt: DateTime!
}

type Query {
  categories(after: ID, first: Int = 20): CategoryConnection
  category(id: ID!): Category
  node(id: ID!): Node
  product(id: ID!): Product
  products(after: ID, first: Int = 20): ProductConnection!
  shop: Shop!
}

type Shop implements Node {
  about: String
  address: ShopAddress!
  categories(after: ID, first: Int = 20): CategoryConnection
  contactEmail: String
  contactPhone: String
  currencyCode: String!
  defaultDomain: String!
  facebookLink: String
  id: ID!
  images: ShopImages!
  instagramLink: String
  products(after: ID, first: Int = 20): ProductConnection
  seoDescription: String
  seoKeywords: [String!]!
  seoTitle: String
  shopProductsCategory: String
  title: String!
  whatsAppLink: String
  whatsAppNumber: String
}

type ShopAddress {
  address: String!
}

input ShopAddressInput {
  address: String!
}

type ShopImages {
  banner: Image
  coverImage: Image
  favicon: Image
  siteLogo: Image
}

interface UserError {
  code: ErrorCode!
  message: String!
  path: [String!]!
}
