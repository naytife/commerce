// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: attribute.sql

package db

import (
	"context"
)

const createAttribute = `-- name: CreateAttribute :one
INSERT INTO attributes (title, data_type, unit, required, applies_to, product_type_id, shop_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING attribute_id, title, data_type, unit, required, applies_to, product_type_id, shop_id
`

type CreateAttributeParams struct {
	Title         string             `json:"title"`
	DataType      AttributeDataType  `json:"data_type"`
	Unit          NullAttributeUnit  `json:"unit"`
	Required      bool               `json:"required"`
	AppliesTo     AttributeAppliesTo `json:"applies_to"`
	ProductTypeID int64              `json:"product_type_id"`
	ShopID        int64              `json:"shop_id"`
}

func (q *Queries) CreateAttribute(ctx context.Context, arg CreateAttributeParams) (Attribute, error) {
	row := q.db.QueryRow(ctx, createAttribute,
		arg.Title,
		arg.DataType,
		arg.Unit,
		arg.Required,
		arg.AppliesTo,
		arg.ProductTypeID,
		arg.ShopID,
	)
	var i Attribute
	err := row.Scan(
		&i.AttributeID,
		&i.Title,
		&i.DataType,
		&i.Unit,
		&i.Required,
		&i.AppliesTo,
		&i.ProductTypeID,
		&i.ShopID,
	)
	return i, err
}

const deleteAttribute = `-- name: DeleteAttribute :exec
DELETE FROM attributes
WHERE attribute_id = $1 AND shop_id = $2
RETURNING attribute_id, title, data_type, unit, required, applies_to, product_type_id, shop_id
`

type DeleteAttributeParams struct {
	AttributeID int64 `json:"attribute_id"`
	ShopID      int64 `json:"shop_id"`
}

func (q *Queries) DeleteAttribute(ctx context.Context, arg DeleteAttributeParams) error {
	_, err := q.db.Exec(ctx, deleteAttribute, arg.AttributeID, arg.ShopID)
	return err
}

const getAttribute = `-- name: GetAttribute :one
SELECT 
    a.attribute_id, a.title, a.data_type, a.unit, a.required, a.applies_to, a.product_type_id, a.shop_id, 
    COALESCE(
        jsonb_agg(
            jsonb_build_object(
                'attribute_option_id', ao.attribute_option_id,
                'value', ao.value
            )
        ) FILTER (WHERE ao.attribute_option_id IS NOT NULL),
        '[]'::jsonb
    )::jsonb AS options
FROM attributes a
LEFT JOIN attribute_options ao ON a.attribute_id = ao.attribute_id
WHERE a.attribute_id = $1 AND a.shop_id = $2
GROUP BY a.attribute_id
`

type GetAttributeParams struct {
	AttributeID int64 `json:"attribute_id"`
	ShopID      int64 `json:"shop_id"`
}

type GetAttributeRow struct {
	AttributeID   int64              `json:"attribute_id"`
	Title         string             `json:"title"`
	DataType      AttributeDataType  `json:"data_type"`
	Unit          NullAttributeUnit  `json:"unit"`
	Required      bool               `json:"required"`
	AppliesTo     AttributeAppliesTo `json:"applies_to"`
	ProductTypeID int64              `json:"product_type_id"`
	ShopID        int64              `json:"shop_id"`
	Options       []byte             `json:"options"`
}

func (q *Queries) GetAttribute(ctx context.Context, arg GetAttributeParams) (GetAttributeRow, error) {
	row := q.db.QueryRow(ctx, getAttribute, arg.AttributeID, arg.ShopID)
	var i GetAttributeRow
	err := row.Scan(
		&i.AttributeID,
		&i.Title,
		&i.DataType,
		&i.Unit,
		&i.Required,
		&i.AppliesTo,
		&i.ProductTypeID,
		&i.ShopID,
		&i.Options,
	)
	return i, err
}

const getAttributeOptions = `-- name: GetAttributeOptions :many
SELECT attribute_option_id, value, shop_id, attribute_id FROM attribute_options WHERE attribute_id = $1 AND shop_id = $2
`

type GetAttributeOptionsParams struct {
	AttributeID int64 `json:"attribute_id"`
	ShopID      int64 `json:"shop_id"`
}

func (q *Queries) GetAttributeOptions(ctx context.Context, arg GetAttributeOptionsParams) ([]AttributeOption, error) {
	rows, err := q.db.Query(ctx, getAttributeOptions, arg.AttributeID, arg.ShopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AttributeOption
	for rows.Next() {
		var i AttributeOption
		if err := rows.Scan(
			&i.AttributeOptionID,
			&i.Value,
			&i.ShopID,
			&i.AttributeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttributes = `-- name: GetAttributes :many
SELECT 
    a.attribute_id, 
    a.title, 
    a.data_type, 
    a.unit, 
    a.required, 
    a.applies_to, 
    a.shop_id, 
    a.product_type_id,
    COALESCE(
        jsonb_agg(
            jsonb_build_object(
                'attribute_option_id', ao.attribute_option_id,
                'value', ao.value
            )
        ) FILTER (WHERE ao.attribute_option_id IS NOT NULL),
        '[]'::jsonb
    )::jsonb AS options
FROM attributes a
LEFT JOIN attribute_options ao ON a.attribute_id = ao.attribute_id
WHERE a.product_type_id = $1 
  AND a.shop_id = $2
  AND ($3::text = '' OR applies_to = $3::attribute_applies_to)
GROUP BY a.attribute_id
`

type GetAttributesParams struct {
	ProductTypeID int64  `json:"product_type_id"`
	ShopID        int64  `json:"shop_id"`
	AppliesTo     string `json:"applies_to"`
}

type GetAttributesRow struct {
	AttributeID   int64              `json:"attribute_id"`
	Title         string             `json:"title"`
	DataType      AttributeDataType  `json:"data_type"`
	Unit          NullAttributeUnit  `json:"unit"`
	Required      bool               `json:"required"`
	AppliesTo     AttributeAppliesTo `json:"applies_to"`
	ShopID        int64              `json:"shop_id"`
	ProductTypeID int64              `json:"product_type_id"`
	Options       []byte             `json:"options"`
}

func (q *Queries) GetAttributes(ctx context.Context, arg GetAttributesParams) ([]GetAttributesRow, error) {
	rows, err := q.db.Query(ctx, getAttributes, arg.ProductTypeID, arg.ShopID, arg.AppliesTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAttributesRow
	for rows.Next() {
		var i GetAttributesRow
		if err := rows.Scan(
			&i.AttributeID,
			&i.Title,
			&i.DataType,
			&i.Unit,
			&i.Required,
			&i.AppliesTo,
			&i.ShopID,
			&i.ProductTypeID,
			&i.Options,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductAttributeValues = `-- name: GetProductAttributeValues :many
SELECT 
    pav.product_id,
    pav.attribute_id,
    pav.shop_id,
    pav.attribute_option_id,
    COALESCE(ao.value, pav.value) as value
FROM product_attribute_values pav
LEFT JOIN attribute_options ao ON ao.attribute_option_id = pav.attribute_option_id
WHERE pav.product_id = $1 AND pav.shop_id = $2
`

type GetProductAttributeValuesParams struct {
	ProductID int64 `json:"product_id"`
	ShopID    int64 `json:"shop_id"`
}

type GetProductAttributeValuesRow struct {
	ProductID         int64  `json:"product_id"`
	AttributeID       int64  `json:"attribute_id"`
	ShopID            int64  `json:"shop_id"`
	AttributeOptionID *int64 `json:"attribute_option_id"`
	Value             string `json:"value"`
}

func (q *Queries) GetProductAttributeValues(ctx context.Context, arg GetProductAttributeValuesParams) ([]GetProductAttributeValuesRow, error) {
	rows, err := q.db.Query(ctx, getProductAttributeValues, arg.ProductID, arg.ShopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductAttributeValuesRow
	for rows.Next() {
		var i GetProductAttributeValuesRow
		if err := rows.Scan(
			&i.ProductID,
			&i.AttributeID,
			&i.ShopID,
			&i.AttributeOptionID,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductVariationAttributeValues = `-- name: GetProductVariationAttributeValues :many
SELECT 
    pvav.product_variation_id,
    pvav.attribute_id,
    pvav.shop_id,
    pvav.attribute_option_id,
    COALESCE(ao.value, pvav.value) as value
FROM product_variation_attribute_values pvav
LEFT JOIN attribute_options ao ON ao.attribute_option_id = pvav.attribute_option_id
WHERE pvav.product_variation_id = $1 AND pvav.shop_id = $2
`

type GetProductVariationAttributeValuesParams struct {
	ProductVariationID int64 `json:"product_variation_id"`
	ShopID             int64 `json:"shop_id"`
}

type GetProductVariationAttributeValuesRow struct {
	ProductVariationID int64  `json:"product_variation_id"`
	AttributeID        int64  `json:"attribute_id"`
	ShopID             int64  `json:"shop_id"`
	AttributeOptionID  *int64 `json:"attribute_option_id"`
	Value              string `json:"value"`
}

func (q *Queries) GetProductVariationAttributeValues(ctx context.Context, arg GetProductVariationAttributeValuesParams) ([]GetProductVariationAttributeValuesRow, error) {
	rows, err := q.db.Query(ctx, getProductVariationAttributeValues, arg.ProductVariationID, arg.ShopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductVariationAttributeValuesRow
	for rows.Next() {
		var i GetProductVariationAttributeValuesRow
		if err := rows.Scan(
			&i.ProductVariationID,
			&i.AttributeID,
			&i.ShopID,
			&i.AttributeOptionID,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsAttributes = `-- name: GetProductsAttributes :many
SELECT
    a.attribute_id, 
    a.title, 
    a.data_type, 
    a.unit, 
    a.required, 
    a.applies_to, 
    a.shop_id, 
    a.product_type_id,
    COALESCE(
        jsonb_agg(
            jsonb_build_object(
                'attribute_option_id', ao.attribute_option_id,
                'value', ao.value
            )
        ) FILTER (WHERE ao.attribute_option_id IS NOT NULL),
        '[]'::jsonb
    )::jsonb AS options
FROM attributes a
LEFT JOIN attribute_options ao ON a.attribute_id = ao.attribute_id
WHERE a.applies_to = 'Product' 
  AND a.product_type_id = $1 
  AND a.shop_id = $2
GROUP BY a.attribute_id
`

type GetProductsAttributesParams struct {
	ProductTypeID int64 `json:"product_type_id"`
	ShopID        int64 `json:"shop_id"`
}

type GetProductsAttributesRow struct {
	AttributeID   int64              `json:"attribute_id"`
	Title         string             `json:"title"`
	DataType      AttributeDataType  `json:"data_type"`
	Unit          NullAttributeUnit  `json:"unit"`
	Required      bool               `json:"required"`
	AppliesTo     AttributeAppliesTo `json:"applies_to"`
	ShopID        int64              `json:"shop_id"`
	ProductTypeID int64              `json:"product_type_id"`
	Options       []byte             `json:"options"`
}

func (q *Queries) GetProductsAttributes(ctx context.Context, arg GetProductsAttributesParams) ([]GetProductsAttributesRow, error) {
	rows, err := q.db.Query(ctx, getProductsAttributes, arg.ProductTypeID, arg.ShopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsAttributesRow
	for rows.Next() {
		var i GetProductsAttributesRow
		if err := rows.Scan(
			&i.AttributeID,
			&i.Title,
			&i.DataType,
			&i.Unit,
			&i.Required,
			&i.AppliesTo,
			&i.ShopID,
			&i.ProductTypeID,
			&i.Options,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariationsAttributes = `-- name: GetVariationsAttributes :many
SELECT
    a.attribute_id, 
    a.title, 
    a.data_type, 
    a.unit, 
    a.required, 
    a.applies_to, 
    a.shop_id, 
    a.product_type_id,
    COALESCE(
        jsonb_agg(
            jsonb_build_object(
                'attribute_option_id', ao.attribute_option_id,
                'value', ao.value
            )
        ) FILTER (WHERE ao.attribute_option_id IS NOT NULL),
        '[]'::jsonb
    )::jsonb AS options
FROM attributes a
LEFT JOIN attribute_options ao ON a.attribute_id = ao.attribute_id
WHERE a.applies_to = 'ProductVariation' 
  AND a.product_type_id = $1 
  AND a.shop_id = $2
GROUP BY a.attribute_id
`

type GetVariationsAttributesParams struct {
	ProductTypeID int64 `json:"product_type_id"`
	ShopID        int64 `json:"shop_id"`
}

type GetVariationsAttributesRow struct {
	AttributeID   int64              `json:"attribute_id"`
	Title         string             `json:"title"`
	DataType      AttributeDataType  `json:"data_type"`
	Unit          NullAttributeUnit  `json:"unit"`
	Required      bool               `json:"required"`
	AppliesTo     AttributeAppliesTo `json:"applies_to"`
	ShopID        int64              `json:"shop_id"`
	ProductTypeID int64              `json:"product_type_id"`
	Options       []byte             `json:"options"`
}

func (q *Queries) GetVariationsAttributes(ctx context.Context, arg GetVariationsAttributesParams) ([]GetVariationsAttributesRow, error) {
	rows, err := q.db.Query(ctx, getVariationsAttributes, arg.ProductTypeID, arg.ShopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVariationsAttributesRow
	for rows.Next() {
		var i GetVariationsAttributesRow
		if err := rows.Scan(
			&i.AttributeID,
			&i.Title,
			&i.DataType,
			&i.Unit,
			&i.Required,
			&i.AppliesTo,
			&i.ShopID,
			&i.ProductTypeID,
			&i.Options,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAttribute = `-- name: UpdateAttribute :one
UPDATE attributes
SET 
    title = COALESCE($1, title),
    data_type = COALESCE($2, data_type),
    unit = COALESCE($3, unit),
    required = COALESCE($4, required),
    applies_to = COALESCE($5, applies_to)
WHERE attribute_id = $6 AND shop_id = $7
RETURNING attribute_id, title, data_type, unit, required, applies_to, product_type_id, shop_id
`

type UpdateAttributeParams struct {
	Title       *string                `json:"title"`
	DataType    NullAttributeDataType  `json:"data_type"`
	Unit        NullAttributeUnit      `json:"unit"`
	Required    *bool                  `json:"required"`
	AppliesTo   NullAttributeAppliesTo `json:"applies_to"`
	AttributeID int64                  `json:"attribute_id"`
	ShopID      int64                  `json:"shop_id"`
}

func (q *Queries) UpdateAttribute(ctx context.Context, arg UpdateAttributeParams) (Attribute, error) {
	row := q.db.QueryRow(ctx, updateAttribute,
		arg.Title,
		arg.DataType,
		arg.Unit,
		arg.Required,
		arg.AppliesTo,
		arg.AttributeID,
		arg.ShopID,
	)
	var i Attribute
	err := row.Scan(
		&i.AttributeID,
		&i.Title,
		&i.DataType,
		&i.Unit,
		&i.Required,
		&i.AppliesTo,
		&i.ProductTypeID,
		&i.ShopID,
	)
	return i, err
}

const updateAttributeOption = `-- name: UpdateAttributeOption :one
UPDATE attribute_options
SET 
    value = COALESCE($1, value)
WHERE attribute_option_id = $2 AND shop_id = $3
RETURNING attribute_option_id, value, shop_id, attribute_id
`

type UpdateAttributeOptionParams struct {
	Value             *string `json:"value"`
	AttributeOptionID int64   `json:"attribute_option_id"`
	ShopID            int64   `json:"shop_id"`
}

func (q *Queries) UpdateAttributeOption(ctx context.Context, arg UpdateAttributeOptionParams) (AttributeOption, error) {
	row := q.db.QueryRow(ctx, updateAttributeOption, arg.Value, arg.AttributeOptionID, arg.ShopID)
	var i AttributeOption
	err := row.Scan(
		&i.AttributeOptionID,
		&i.Value,
		&i.ShopID,
		&i.AttributeID,
	)
	return i, err
}
