// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: analytics.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCustomerSummaryNewReturning = `-- name: GetCustomerSummaryNewReturning :one
SELECT
  COUNT(DISTINCT CASE WHEN o.created_at BETWEEN $2 AND $3 THEN o.customer_email END) AS new_customers,
  COUNT(DISTINCT CASE WHEN o.created_at < $2 THEN o.customer_email END) AS returning_customers
FROM orders o
WHERE o.shop_id = $1 AND o.created_at BETWEEN $2 AND $3 AND o.status = 'completed' AND o.customer_email IS NOT NULL
`

type GetCustomerSummaryNewReturningParams struct {
	ShopID      int64              `json:"shop_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetCustomerSummaryNewReturningRow struct {
	NewCustomers       int64 `json:"new_customers"`
	ReturningCustomers int64 `json:"returning_customers"`
}

func (q *Queries) GetCustomerSummaryNewReturning(ctx context.Context, arg GetCustomerSummaryNewReturningParams) (GetCustomerSummaryNewReturningRow, error) {
	row := q.db.QueryRow(ctx, getCustomerSummaryNewReturning, arg.ShopID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetCustomerSummaryNewReturningRow
	err := row.Scan(&i.NewCustomers, &i.ReturningCustomers)
	return i, err
}

const getCustomerSummaryTop = `-- name: GetCustomerSummaryTop :many
SELECT
  o.customer_email,
  MAX(o.customer_name) AS name,
  COUNT(o.order_id) AS orders,
  SUM(o.amount) AS total_spent,
  CASE WHEN sc.shop_customer_id IS NOT NULL THEN true ELSE false END AS is_registered
FROM orders o
LEFT JOIN shop_customers sc ON o.shop_id = sc.shop_id AND o.customer_email = sc.email
WHERE o.shop_id = $1 AND o.created_at BETWEEN $2 AND $3 AND o.status = 'completed' AND o.customer_email IS NOT NULL
GROUP BY o.customer_email, sc.shop_customer_id
ORDER BY total_spent DESC
LIMIT 5
`

type GetCustomerSummaryTopParams struct {
	ShopID      int64              `json:"shop_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetCustomerSummaryTopRow struct {
	CustomerEmail *string     `json:"customer_email"`
	Name          interface{} `json:"name"`
	Orders        int64       `json:"orders"`
	TotalSpent    int64       `json:"total_spent"`
	IsRegistered  bool        `json:"is_registered"`
}

func (q *Queries) GetCustomerSummaryTop(ctx context.Context, arg GetCustomerSummaryTopParams) ([]GetCustomerSummaryTopRow, error) {
	rows, err := q.db.Query(ctx, getCustomerSummaryTop, arg.ShopID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCustomerSummaryTopRow
	for rows.Next() {
		var i GetCustomerSummaryTopRow
		if err := rows.Scan(
			&i.CustomerEmail,
			&i.Name,
			&i.Orders,
			&i.TotalSpent,
			&i.IsRegistered,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLowStockProducts = `-- name: GetLowStockProducts :many
SELECT
  pv.product_variation_id,
  p.title AS product_name,
  pv.sku,
  pv.description,
  pv.available_quantity AS stock
FROM product_variations pv
JOIN products p ON pv.product_id = p.product_id
WHERE pv.shop_id = $1 AND pv.available_quantity <= $2
ORDER BY pv.available_quantity ASC
`

type GetLowStockProductsParams struct {
	ShopID            int64 `json:"shop_id"`
	AvailableQuantity int64 `json:"available_quantity"`
}

type GetLowStockProductsRow struct {
	ProductVariationID int64  `json:"product_variation_id"`
	ProductName        string `json:"product_name"`
	Sku                string `json:"sku"`
	Description        string `json:"description"`
	Stock              int64  `json:"stock"`
}

func (q *Queries) GetLowStockProducts(ctx context.Context, arg GetLowStockProductsParams) ([]GetLowStockProductsRow, error) {
	rows, err := q.db.Query(ctx, getLowStockProducts, arg.ShopID, arg.AvailableQuantity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLowStockProductsRow
	for rows.Next() {
		var i GetLowStockProductsRow
		if err := rows.Scan(
			&i.ProductVariationID,
			&i.ProductName,
			&i.Sku,
			&i.Description,
			&i.Stock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersOverTime = `-- name: GetOrdersOverTime :many
SELECT
  DATE_TRUNC($1, day)::date AS period,
  COALESCE(SUM(total_orders), 0) AS order_count
FROM daily_sales
WHERE shop_id = $2 AND day BETWEEN $3 AND $4
GROUP BY period
ORDER BY period ASC
`

type GetOrdersOverTimeParams struct {
	DateTrunc string      `json:"date_trunc"`
	ShopID    int64       `json:"shop_id"`
	Day       pgtype.Date `json:"day"`
	Day_2     pgtype.Date `json:"day_2"`
}

type GetOrdersOverTimeRow struct {
	Period     pgtype.Date `json:"period"`
	OrderCount interface{} `json:"order_count"`
}

func (q *Queries) GetOrdersOverTime(ctx context.Context, arg GetOrdersOverTimeParams) ([]GetOrdersOverTimeRow, error) {
	rows, err := q.db.Query(ctx, getOrdersOverTime,
		arg.DateTrunc,
		arg.ShopID,
		arg.Day,
		arg.Day_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersOverTimeRow
	for rows.Next() {
		var i GetOrdersOverTimeRow
		if err := rows.Scan(&i.Period, &i.OrderCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesSummary = `-- name: GetSalesSummary :one
SELECT
  COALESCE(SUM(revenue), 0) AS total_sales,
  COALESCE(SUM(total_orders), 0) AS total_orders,
  COALESCE(SUM(revenue)/NULLIF(SUM(total_orders),0),0) AS average_order_value
FROM daily_sales
WHERE shop_id = $1 AND day BETWEEN $2 AND $3
`

type GetSalesSummaryParams struct {
	ShopID int64       `json:"shop_id"`
	Day    pgtype.Date `json:"day"`
	Day_2  pgtype.Date `json:"day_2"`
}

type GetSalesSummaryRow struct {
	TotalSales        interface{} `json:"total_sales"`
	TotalOrders       interface{} `json:"total_orders"`
	AverageOrderValue interface{} `json:"average_order_value"`
}

func (q *Queries) GetSalesSummary(ctx context.Context, arg GetSalesSummaryParams) (GetSalesSummaryRow, error) {
	row := q.db.QueryRow(ctx, getSalesSummary, arg.ShopID, arg.Day, arg.Day_2)
	var i GetSalesSummaryRow
	err := row.Scan(&i.TotalSales, &i.TotalOrders, &i.AverageOrderValue)
	return i, err
}

const getTopProducts = `-- name: GetTopProducts :many
SELECT
  oi.product_variation_id,
  p.title AS product_name,
  COALESCE(SUM(oi.quantity), 0) AS units_sold,
  COALESCE(SUM(oi.quantity * oi.price), 0) AS revenue
FROM order_items oi
JOIN orders o ON oi.order_id = o.order_id
JOIN product_variations pv ON oi.product_variation_id = pv.product_variation_id
JOIN products p ON pv.product_id = p.product_id
WHERE o.shop_id = $1 AND o.created_at BETWEEN $2 AND $3 AND o.status = 'completed'
GROUP BY oi.product_variation_id, p.title
ORDER BY units_sold DESC
LIMIT $4
`

type GetTopProductsParams struct {
	ShopID      int64              `json:"shop_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Limit       int32              `json:"limit"`
}

type GetTopProductsRow struct {
	ProductVariationID int64       `json:"product_variation_id"`
	ProductName        string      `json:"product_name"`
	UnitsSold          interface{} `json:"units_sold"`
	Revenue            interface{} `json:"revenue"`
}

func (q *Queries) GetTopProducts(ctx context.Context, arg GetTopProductsParams) ([]GetTopProductsRow, error) {
	rows, err := q.db.Query(ctx, getTopProducts,
		arg.ShopID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopProductsRow
	for rows.Next() {
		var i GetTopProductsRow
		if err := rows.Scan(
			&i.ProductVariationID,
			&i.ProductName,
			&i.UnitsSold,
			&i.Revenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
