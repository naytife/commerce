package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.54

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"math/big"
	"strconv"

	"github.com/gosimple/slug"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/petrejonn/naytife/internal/db"
	"github.com/petrejonn/naytife/internal/graph/generated"
	"github.com/petrejonn/naytife/internal/graph/model"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, product model.CreateProductInput) (model.CreateProductPayload, error) {
	shopID := ctx.Value("shop_id").(int64)
	_, catID, err := decodeRelayID(product.CategoryID)
	if err != nil {
		return nil, errors.New("invalid category ID")
	}
	cat, err := r.Repository.GetCategory(ctx, db.GetCategoryParams{ShopID: shopID, CategoryID: *catID})
	if err != nil {
		return &model.CategoryNotFoundError{Message: "category not found", Code: model.ErrorCodeNotFoundCategory}, nil
	}
	param := db.CreateProductParams{
		Title:             product.Title,
		Description:       product.Description,
		ShopID:            shopID,
		CategoryID:        *catID,
		AllowedAttributes: cat.CategoryAttributes,
		Status:            model.ProductStatusDraft.String(),
	}
	dbProduct, err := r.Repository.CreateProduct(ctx, param)
	if err != nil {
		log.Println(err)
		return nil, errors.New("server error")
	}
	return model.CreateProductSuccess{Product: &model.Product{
		ID:          strconv.FormatInt(dbProduct.ProductID, 10),
		Title:       dbProduct.Title,
		Description: dbProduct.Description,
		Status:      (*model.ProductStatus)(&dbProduct.Status),
		CreatedAt:   dbProduct.CreatedAt.Time,
		UpdatedAt:   dbProduct.UpdatedAt.Time,
	}}, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, productID string, product model.UpdateProductInput) (model.UpdateProductPayload, error) {
	_, objID, err := decodeRelayID(productID)
	if err != nil {
		return nil, errors.New("invalid object ID")
	}
	params := db.UpdateProductParams{
		ProductID:   *objID,
		Title:       product.Title,
		Description: product.Description,
	}
	objDB, err := r.Repository.UpdateProduct(ctx, params)
	if err != nil {
		return nil, errors.New("could not update object")
	}
	return &model.UpdateProductSuccess{
		Product: &model.Product{
			ID:          strconv.FormatInt(objDB.ProductID, 10),
			Title:       objDB.Title,
			Description: objDB.Description,
			CreatedAt:   objDB.CreatedAt.Time,
			UpdatedAt:   objDB.UpdatedAt.Time,
		}}, nil
}

// CreateProductAttribute is the resolver for the createProductAttribute field.
func (r *mutationResolver) CreateProductAttribute(ctx context.Context, productID string, attribute model.CreateProductAttributeInput) (model.CreateProductAttributePayload, error) {
	_, objID, err := decodeRelayID(productID)
	if err != nil {
		return nil, errors.New("invalid object ID")
	}
	objsDB, err := r.Repository.CreateProductAllowedAttribute(ctx, db.CreateProductAllowedAttributeParams{
		ProductID: *objID,
		Title:     attribute.Title,
		DataType:  attribute.DataType.String(),
	})
	if err != nil {
		return nil, errors.New("could not create object attribute")
	}
	objs, err := unmarshalAllowedProductAttributes(objsDB)
	if err != nil {
		return nil, errors.New("failed to serialize attributes")
	}
	return &model.CreateProductAttributeSuccess{
		Attributes: objs,
	}, nil
}

// DeleteProductAttribute is the resolver for the deleteProductAttribute field.
func (r *mutationResolver) DeleteProductAttribute(ctx context.Context, productID string, attribute string) (model.DeleteProductAttributePayload, error) {
	_, objID, err := decodeRelayID(productID)
	if err != nil {
		return nil, errors.New("invalid object ID")
	}
	objsDB, err := r.Repository.DeleteProductAllowedAttribute(ctx, db.DeleteProductAllowedAttributeParams{
		ProductID: *objID, Attribute: attribute,
	})
	if err != nil {
		return nil, errors.New("could not fetch object attribute")
	}
	objs, err := unmarshalAllowedProductAttributes(objsDB)
	if err != nil {
		return nil, errors.New("failed to fetch attributes")
	}
	return &model.DeleteProductAttributeSuccess{
		Attributes: objs,
	}, nil
}

// CreateProductVariant is the resolver for the createProductVariant field.
func (r *mutationResolver) CreateProductVariant(ctx context.Context, productID string, variants []model.CreateProductVariantInput) (model.CreateProductVariantPayload, error) {
	shopID := ctx.Value("shop_id").(int64)
	_, objID, err := decodeRelayID(productID)
	if err != nil {
		return nil, errors.New("invalid product ID")
	}
	attributesDB, err := r.Repository.GetProductAllowedAttributes(ctx, *objID)
	if err != nil {
		return nil, errors.New("could not fetch product attribute")
	}
	// Unmarshal JSONB ([]byte) into a Go map
	var attributesDBMap map[string]interface{}
	if err := json.Unmarshal(attributesDB, &attributesDBMap); err != nil {
		return nil, err
	}
	params := []db.UpsertProductVariationParams{}
	for _, variant := range variants {
		if err := validateProductVariantInput(variant, attributesDBMap); err != nil {
			return nil, fmt.Errorf("validation error: %v", err)
		}
		attributesJSON, err := json.Marshal(variant.Attributes)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize attributes: %v", err)
		}
		attributesString := formatAttributes(variant.Attributes)
		params = append(params, db.UpsertProductVariationParams{
			Slug:              slug.MakeLang(attributesString, "en"),
			Description:       attributesString,
			Price:             pgtype.Numeric{Int: big.NewInt(int64(variant.Price)), Valid: true},
			AvailableQuantity: int64(variant.AvailableQuantity),
			Attributes:        attributesJSON,
			ProductID:         *objID,
			ShopID:            shopID,
		})
	}
	objsDB, err := r.Repository.UpsertProductVariations(ctx, shopID, *objID, params)
	if err != nil {
		return nil, fmt.Errorf("failed to create variabtions: %v", err)
	}
	objs := make([]model.ProductVariant, 0, len(objsDB))
	for _, objDB := range objsDB {
		priceFloat64, err := objDB.Price.Float64Value()
		if err != nil {
			log.Fatalf("Failed to convert pgtype.Numeric to float64: %v", err)
		}
		objs = append(objs, model.ProductVariant{
			ID:                strconv.FormatInt(objDB.ProductVariationID, 10),
			Slug:              objDB.Slug,
			Description:       objDB.Description,
			Price:             priceFloat64.Float64,
			AvailableQuantity: int(objDB.AvailableQuantity),
			UpdatedAt:         objDB.UpdatedAt.Time,
			CreatedAt:         objDB.CreatedAt.Time,
		})
	}
	return model.CreateProductVariantSuccess{
		Variants: objs,
	}, nil
}

// ID is the resolver for the id field.
func (r *productResolver) ID(ctx context.Context, obj *model.Product) (string, error) {
	return encodeRelayID("Product", obj.ID), nil
}

// DefaultVariant is the resolver for the defaultVariant field.
func (r *productResolver) DefaultVariant(ctx context.Context, obj *model.Product) (*model.ProductVariant, error) {
	panic(fmt.Errorf("not implemented: DefaultVariant - defaultVariant"))
}

// Variants is the resolver for the variants field.
func (r *productResolver) Variants(ctx context.Context, obj *model.Product) ([]model.ProductVariant, error) {
	shopID := ctx.Value("shop_id").(int64)
	objID, err := strconv.Atoi(obj.ID)
	if err != nil {
		return nil, errors.New("invalid product id")
	}
	objsDB, err := r.Repository.GetProductVariations(ctx, db.GetProductVariationsParams{ShopID: shopID, ProductID: int64(objID)})
	if err != nil {
		return nil, errors.New("could not fetch objects")
	}
	objs := make([]model.ProductVariant, 0, len(objsDB))
	for _, objDB := range objsDB {
		priceFloat64, err := objDB.Price.Float64Value()
		if err != nil {
			log.Fatalf("Failed to convert pgtype.Numeric to float64: %v", err)
		}
		attributes, err := unmarshalProductAttributes(objDB.Attributes)
		if err != nil {
			log.Fatalf("Failed to unmarshal product attributes: %v", err)
		}
		objs = append(objs, model.ProductVariant{
			ID:                strconv.FormatInt(objDB.ProductVariationID, 10),
			Slug:              objDB.Slug,
			Description:       objDB.Description,
			Price:             priceFloat64.Float64,
			AvailableQuantity: int(objDB.AvailableQuantity),
			Attributes:        attributes,
			UpdatedAt:         objDB.UpdatedAt.Time,
			CreatedAt:         objDB.CreatedAt.Time,
		})
	}
	return objs, nil
}

// AllowedAttributes is the resolver for the allowedAttributes field.
func (r *productResolver) AllowedAttributes(ctx context.Context, obj *model.Product) ([]model.AllowedProductAttributes, error) {
	objID, err := strconv.Atoi(obj.ID)
	if err != nil {
		return nil, errors.New("invalid product id")
	}
	attributesDB, err := r.Repository.GetProductAllowedAttributes(ctx, int64(objID))
	if err != nil {
		return nil, errors.New("could not fetch product attribute")
	}
	attributes, err := unmarshalAllowedProductAttributes(attributesDB)
	if err != nil {
		return nil, errors.New("failed to serialize attributes")
	}
	return attributes, nil
}

// Images is the resolver for the images field.
func (r *productResolver) Images(ctx context.Context, obj *model.Product) ([]model.Image, error) {
	panic(fmt.Errorf("not implemented: Images - images"))
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, first *int, after *string) (*model.ProductConnection, error) {
	shopID := ctx.Value("shop_id").(int64)
	limit := 20
	if first != nil {
		limit = *first
	}
	afterID := int64(0)
	if after != nil {
		decodedType, id, err := decodeRelayID(*after)
		if err != nil {
			return nil, fmt.Errorf("invalid after cursor: %w", err)
		}
		if decodedType != "Product" {
			return nil, fmt.Errorf("expected after cursor type 'Product', got '%s'", decodedType)
		}
		if id != nil {
			afterID = *id
		}
	}
	objsDB, err := r.Repository.GetProducts(ctx, db.GetProductsParams{ShopID: shopID, After: afterID, Limit: int32(limit) + 1})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch products: %w", err)
	}
	hasNextPage := len(objsDB) > limit
	if hasNextPage {
		objsDB = objsDB[:limit]
	}
	edges := make([]model.ProductEdge, len(objsDB))
	for i, prod := range objsDB {
		relayID := encodeRelayID("Product", strconv.FormatInt(prod.ProductID, 10))
		edges[i] = model.ProductEdge{Cursor: relayID, Node: &model.Product{
			ID:          strconv.FormatInt(prod.ProductID, 10),
			Title:       prod.Title,
			Description: prod.Description,
			CreatedAt:   prod.CreatedAt.Time,
			UpdatedAt:   prod.UpdatedAt.Time,
			Status:      (*model.ProductStatus)(&prod.Status),
		}}
	}
	var startCursor, endCursor *string
	if len(objsDB) > 0 {
		firstCursor := encodeRelayID("Product", strconv.FormatInt(objsDB[0].ProductID, 10))
		lastCursor := encodeRelayID("Product", strconv.FormatInt(objsDB[len(objsDB)-1].ProductID, 10))
		startCursor, endCursor = &firstCursor, &lastCursor
	}

	pageInfo := &model.PageInfo{
		HasNextPage: hasNextPage,
		StartCursor: safeStringDereference(startCursor),
		EndCursor:   safeStringDereference(endCursor),
	}

	return &model.ProductConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: len(objsDB),
	}, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*model.Product, error) {
	shopID := ctx.Value("shop_id").(int64)
	_, objID, err := decodeRelayID(id)
	if err != nil {
		return nil, errors.New("invalid projec ID")
	}
	objDB, err := r.Repository.GetProduct(ctx, db.GetProductParams{ShopID: shopID, ProductID: *objID})
	if err != nil {
		return nil, errors.New("could not find object")
	}
	return &model.Product{
		ID:          strconv.FormatInt(objDB.ProductID, 10),
		Title:       objDB.Title,
		Description: objDB.Description,
		Status:      (*model.ProductStatus)(&objDB.Status),
		CreatedAt:   objDB.CreatedAt.Time,
		UpdatedAt:   objDB.UpdatedAt.Time,
	}, nil
}

// Product returns generated.ProductResolver implementation.
func (r *Resolver) Product() generated.ProductResolver { return &productResolver{r} }

type productResolver struct{ *Resolver }
