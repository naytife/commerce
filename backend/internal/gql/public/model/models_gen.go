// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type Node interface {
	IsNode()
	GetID() string
}

type UserError interface {
	IsUserError()
	GetMessage() string
	GetCode() ErrorCode
	GetPath() []string
}

type AllowedCategoryAttributes struct {
	Title    string                   `json:"title"`
	DataType ProductAttributeDataType `json:"dataType"`
}

type AllowedProductAttributes struct {
	Title    string                   `json:"title"`
	DataType ProductAttributeDataType `json:"dataType"`
}

type Category struct {
	ID                string                      `json:"id"`
	Slug              string                      `json:"slug"`
	Title             string                      `json:"title"`
	Description       *string                     `json:"description,omitempty"`
	Products          *ProductConnection          `json:"products,omitempty"`
	AllowedAttributes []AllowedCategoryAttributes `json:"allowedAttributes"`
	Images            *CategoryImages             `json:"images,omitempty"`
	UpdatedAt         time.Time                   `json:"updatedAt"`
	CreatedAt         time.Time                   `json:"createdAt"`
}

func (Category) IsNode()            {}
func (this Category) GetID() string { return this.ID }

type CategoryConnection struct {
	Edges      []CategoryEdge `json:"edges"`
	PageInfo   *PageInfo      `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

type CategoryEdge struct {
	Cursor string    `json:"cursor"`
	Node   *Category `json:"node"`
}

type CategoryImages struct {
	Banner *Image `json:"banner"`
}

type CategoryNotFoundError struct {
	Message string    `json:"message"`
	Code    ErrorCode `json:"code"`
	Path    []string  `json:"path"`
}

func (CategoryNotFoundError) IsUserError()            {}
func (this CategoryNotFoundError) GetMessage() string { return this.Message }
func (this CategoryNotFoundError) GetCode() ErrorCode { return this.Code }
func (this CategoryNotFoundError) GetPath() []string {
	if this.Path == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Path))
	for _, concrete := range this.Path {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type Image struct {
	URL     string  `json:"url"`
	AltText *string `json:"altText,omitempty"`
}

type ImageInput struct {
	URL     string  `json:"url"`
	AltText *string `json:"altText,omitempty"`
}

type PageInfo struct {
	StartCursor     string `json:"startCursor"`
	EndCursor       string `json:"endCursor"`
	HasNextPage     bool   `json:"hasNextPage"`
	HasPreviousPage bool   `json:"hasPreviousPage"`
}

type Product struct {
	ID             string           `json:"id"`
	Title          string           `json:"title"`
	Description    string           `json:"description"`
	DefaultVariant *ProductVariant  `json:"defaultVariant"`
	Variants       []ProductVariant `json:"variants"`
	Images         []Image          `json:"images"`
	UpdatedAt      time.Time        `json:"updatedAt"`
	CreatedAt      time.Time        `json:"createdAt"`
}

func (Product) IsNode()            {}
func (this Product) GetID() string { return this.ID }

type ProductAttribute struct {
	Key   string  `json:"key"`
	Value *string `json:"value,omitempty"`
}

type ProductAttributeValue struct {
	IntValue    *int    `json:"intValue,omitempty"`
	StringValue *string `json:"stringValue,omitempty"`
}

type ProductConnection struct {
	Edges      []ProductEdge `json:"edges"`
	PageInfo   *PageInfo     `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

type ProductEdge struct {
	Cursor string   `json:"cursor"`
	Node   *Product `json:"node"`
}

type ProductNotFoundError struct {
	Message string    `json:"message"`
	Code    ErrorCode `json:"code"`
	Path    []string  `json:"path"`
}

func (ProductNotFoundError) IsUserError()            {}
func (this ProductNotFoundError) GetMessage() string { return this.Message }
func (this ProductNotFoundError) GetCode() ErrorCode { return this.Code }
func (this ProductNotFoundError) GetPath() []string {
	if this.Path == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Path))
	for _, concrete := range this.Path {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type ProductVariant struct {
	ID                string             `json:"id"`
	Slug              string             `json:"slug"`
	Price             float64            `json:"price"`
	AvailableQuantity int                `json:"availableQuantity"`
	Description       string             `json:"description"`
	Attributes        []ProductAttribute `json:"attributes"`
	StockStatus       ProductStockStatus `json:"stockStatus"`
	UpdatedAt         time.Time          `json:"updatedAt"`
	CreatedAt         time.Time          `json:"createdAt"`
}

func (ProductVariant) IsNode()            {}
func (this ProductVariant) GetID() string { return this.ID }

type Query struct {
}

type Shop struct {
	ID                   string              `json:"id"`
	Title                string              `json:"title"`
	DefaultDomain        string              `json:"defaultDomain"`
	ContactPhone         *string             `json:"contactPhone,omitempty"`
	ContactEmail         *string             `json:"contactEmail,omitempty"`
	Address              *ShopAddress        `json:"address"`
	Products             *ProductConnection  `json:"products,omitempty"`
	Categories           *CategoryConnection `json:"categories,omitempty"`
	WhatsAppNumber       *string             `json:"whatsAppNumber,omitempty"`
	WhatsAppLink         *string             `json:"whatsAppLink,omitempty"`
	FacebookLink         *string             `json:"facebookLink,omitempty"`
	InstagramLink        *string             `json:"instagramLink,omitempty"`
	Images               *ShopImages         `json:"images"`
	CurrencyCode         string              `json:"currencyCode"`
	About                *string             `json:"about,omitempty"`
	ShopProductsCategory *string             `json:"shopProductsCategory,omitempty"`
	SeoDescription       *string             `json:"seoDescription,omitempty"`
	SeoKeywords          []string            `json:"seoKeywords"`
	SeoTitle             *string             `json:"seoTitle,omitempty"`
}

func (Shop) IsNode()            {}
func (this Shop) GetID() string { return this.ID }

type ShopAddress struct {
	Address string `json:"address"`
}

type ShopAddressInput struct {
	Address string `json:"address"`
}

type ShopImages struct {
	SiteLogo   *Image `json:"siteLogo,omitempty"`
	Favicon    *Image `json:"favicon,omitempty"`
	Banner     *Image `json:"banner,omitempty"`
	CoverImage *Image `json:"coverImage,omitempty"`
}

type ErrorCode string

const (
	ErrorCodeNotFoundShop           ErrorCode = "NOT_FOUND_SHOP"
	ErrorCodeNotFoundCategory       ErrorCode = "NOT_FOUND_CATEGORY"
	ErrorCodeAuthInvalidToken       ErrorCode = "AUTH_INVALID_TOKEN"
	ErrorCodeValidationInvalidInput ErrorCode = "VALIDATION_INVALID_INPUT"
	ErrorCodeServerErrorInternal    ErrorCode = "SERVER_ERROR_INTERNAL"
	ErrorCodeRateLimitExceeded      ErrorCode = "RATE_LIMIT_EXCEEDED"
)

var AllErrorCode = []ErrorCode{
	ErrorCodeNotFoundShop,
	ErrorCodeNotFoundCategory,
	ErrorCodeAuthInvalidToken,
	ErrorCodeValidationInvalidInput,
	ErrorCodeServerErrorInternal,
	ErrorCodeRateLimitExceeded,
}

func (e ErrorCode) IsValid() bool {
	switch e {
	case ErrorCodeNotFoundShop, ErrorCodeNotFoundCategory, ErrorCodeAuthInvalidToken, ErrorCodeValidationInvalidInput, ErrorCodeServerErrorInternal, ErrorCodeRateLimitExceeded:
		return true
	}
	return false
}

func (e ErrorCode) String() string {
	return string(e)
}

func (e *ErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorCode", str)
	}
	return nil
}

func (e ErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProductAttributeDataType string

const (
	ProductAttributeDataTypeString  ProductAttributeDataType = "STRING"
	ProductAttributeDataTypeInteger ProductAttributeDataType = "INTEGER"
)

var AllProductAttributeDataType = []ProductAttributeDataType{
	ProductAttributeDataTypeString,
	ProductAttributeDataTypeInteger,
}

func (e ProductAttributeDataType) IsValid() bool {
	switch e {
	case ProductAttributeDataTypeString, ProductAttributeDataTypeInteger:
		return true
	}
	return false
}

func (e ProductAttributeDataType) String() string {
	return string(e)
}

func (e *ProductAttributeDataType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductAttributeDataType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductAttributeDataType", str)
	}
	return nil
}

func (e ProductAttributeDataType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProductStockStatus string

const (
	ProductStockStatusInStock    ProductStockStatus = "IN_STOCK"
	ProductStockStatusOutOfStock ProductStockStatus = "OUT_OF_STOCK"
	ProductStockStatusPreorder   ProductStockStatus = "PREORDER"
)

var AllProductStockStatus = []ProductStockStatus{
	ProductStockStatusInStock,
	ProductStockStatusOutOfStock,
	ProductStockStatusPreorder,
}

func (e ProductStockStatus) IsValid() bool {
	switch e {
	case ProductStockStatusInStock, ProductStockStatusOutOfStock, ProductStockStatusPreorder:
		return true
	}
	return false
}

func (e ProductStockStatus) String() string {
	return string(e)
}

func (e *ProductStockStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductStockStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductStockStatus", str)
	}
	return nil
}

func (e ProductStockStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
