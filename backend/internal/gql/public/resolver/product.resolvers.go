package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"

	"github.com/petrejonn/naytife/internal/db"
	"github.com/petrejonn/naytife/internal/gql/public/generated"
	"github.com/petrejonn/naytife/internal/gql/public/model"
)

// ID is the resolver for the id field.
func (r *productResolver) ID(ctx context.Context, obj *model.Product) (string, error) {
	return encodeRelayID("Product", strconv.FormatInt(int64(obj.ProductID), 10)), nil
}

// Images is the resolver for the images field.
func (r *productResolver) Images(ctx context.Context, obj *model.Product) ([]model.Image, error) {
	shopID := ctx.Value("shop_id").(int64)

	// Get product images from database
	images, err := r.Repository.GetProductImages(ctx, db.GetProductImagesParams{
		ProductID: int64(obj.ProductID),
		ShopID:    shopID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch product images: %w", err)
	}

	// Convert db.ProductImage to model.Image
	result := make([]model.Image, len(images))
	for i, img := range images {
		altText := img.Alt
		result[i] = model.Image{
			URL:     img.Url,
			AltText: &altText,
		}
	}

	return result, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, first *int, after *string) (*model.ProductConnection, error) {
	shopID := ctx.Value("shop_id").(int64)
	limit := 20
	if first != nil {
		limit = *first
	}
	afterID := int64(0)
	if after != nil {
		decodedType, id, err := decodeRelayID(*after)
		if err != nil {
			return nil, fmt.Errorf("invalid after cursor: %w", err)
		}
		if decodedType != "Product" {
			return nil, fmt.Errorf("expected after cursor type 'Product', got '%s'", decodedType)
		}
		if id != nil {
			afterID = *id
		}
	}
	objsDB, err := r.Repository.GetProducts(ctx, db.GetProductsParams{ShopID: shopID, After: afterID, Limit: int32(limit) + 1})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch products: %w", err)
	}
	hasNextPage := len(objsDB) > limit
	if hasNextPage {
		objsDB = objsDB[:limit]
	}
	edges := make([]model.ProductEdge, len(objsDB))
	for i, prod := range objsDB {
		relayID := encodeRelayID("Product", strconv.FormatInt(prod.ProductID, 10))
		var attributes []model.ProductAttribute
		var variants []model.ProductVariant

		if err := json.Unmarshal(prod.Attributes, &attributes); err != nil {
			return nil, fmt.Errorf("failed to unmarshal attributes: %w", err)
		}

		if err := json.Unmarshal(prod.Variants, &variants); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variants: %w", err)
		}
		defaultVariant := variants[0]
		for i := range variants {
			variants[i].ID = encodeRelayID("ProductVariant", strconv.FormatInt(int64(variants[i].VariationID), 10))
			if variants[i].IsDefault {
				defaultVariant = variants[i]
				break
			}
		}
		defaultVariant.ID = encodeRelayID("ProductVariant", strconv.FormatInt(int64(defaultVariant.VariationID), 10))
		edges[i] = model.ProductEdge{Cursor: relayID, Node: &model.Product{
			ProductID:   int(prod.ProductID),
			Title:       prod.Title,
			Slug:        prod.Slug,
			Description: prod.Description,
			CreatedAt:   prod.CreatedAt.Time,
			UpdatedAt:   prod.UpdatedAt.Time,
			Attributes:  attributes,
			Variants:    variants,
		}}
		edges[i].Node.DefaultVariant = &defaultVariant

	}
	var startCursor, endCursor *string
	if len(objsDB) > 0 {
		firstCursor := encodeRelayID("Product", strconv.FormatInt(objsDB[0].ProductID, 10))
		lastCursor := encodeRelayID("Product", strconv.FormatInt(objsDB[len(objsDB)-1].ProductID, 10))
		startCursor, endCursor = &firstCursor, &lastCursor
	}

	pageInfo := &model.PageInfo{
		HasNextPage: hasNextPage,
		StartCursor: safeStringDereference(startCursor),
		EndCursor:   safeStringDereference(endCursor),
	}

	return &model.ProductConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: len(objsDB),
	}, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*model.Product, error) {
	shopID := ctx.Value("shop_id").(int64)
	_, objID, err := decodeRelayID(id)
	if err != nil {
		return nil, errors.New("invalid projec ID")
	}
	objDB, err := r.Repository.GetProduct(ctx, db.GetProductParams{ShopID: shopID, ProductID: *objID})
	if err != nil {
		return nil, errors.New("could not find object")
	}
	var attributes []model.ProductAttribute
	var variants []model.ProductVariant

	if err := json.Unmarshal(objDB.Attributes, &attributes); err != nil {
		return nil, fmt.Errorf("failed to unmarshal attributes: %w", err)
	}

	if err := json.Unmarshal(objDB.Variants, &variants); err != nil {
		return nil, fmt.Errorf("failed to unmarshal variants: %w", err)
	}
	defaultVariant := variants[0]
	for i := range variants {
		variants[i].ID = encodeRelayID("ProductVariant", strconv.FormatInt(int64(variants[i].VariationID), 10))
		if variants[i].IsDefault {
			defaultVariant = variants[i]
		}
	}
	defaultVariant.ID = encodeRelayID("ProductVariant", strconv.FormatInt(int64(defaultVariant.VariationID), 10))
	return &model.Product{
		ProductID:      int(objDB.ProductID),
		Title:          objDB.Title,
		Description:    objDB.Description,
		CreatedAt:      objDB.CreatedAt.Time,
		UpdatedAt:      objDB.UpdatedAt.Time,
		Attributes:     attributes,
		Variants:       variants,
		DefaultVariant: &defaultVariant,
		Slug:           objDB.Slug,
	}, nil
}

// Product returns generated.ProductResolver implementation.
func (r *Resolver) Product() generated.ProductResolver { return &productResolver{r} }

type productResolver struct{ *Resolver }
