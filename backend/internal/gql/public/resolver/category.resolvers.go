package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.75

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"

	"github.com/petrejonn/naytife/internal/db"
	"github.com/petrejonn/naytife/internal/gql/public/generated"
	"github.com/petrejonn/naytife/internal/gql/public/model"
)

// ID is the resolver for the id field.
func (r *categoryResolver) ID(ctx context.Context, obj *model.Category) (string, error) {
	return EncodeStringID("Category", obj.ID), nil
}

// Products is the resolver for the products field.
func (r *categoryResolver) Products(ctx context.Context, obj *model.Category, first *int, after *string) (*model.ProductConnection, error) {
	shopID := ctx.Value("shop_id").(int64)
	limit := 20
	if first != nil {
		limit = *first
	}

	afterID := int64(0)
	// Parse the after cursor if provided
	if after != nil && *after != "" {
		decodedType, id, err := decodeRelayID(*after)
		if err != nil {
			return nil, fmt.Errorf("invalid cursor format: %w", err)
		}
		if decodedType != "Product" {
			return nil, fmt.Errorf("expected cursor type 'Product', got '%s'", decodedType)
		}
		if id != nil {
			afterID = *id
		}
	}

	// Convert string ID to int64 if needed
	var categoryID *int64
	if obj.ID != "" {
		catID, err := strconv.ParseInt(obj.ID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid category ID: %w", err)
		}
		categoryID = &catID
	}

	productsDB, err := r.Repository.GetProductsByCategory(ctx, db.GetProductsByCategoryParams{CategoryID: categoryID, After: afterID, Limit: int32(limit) + 1})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch products: %w", err)
	}

	hasNextPage := len(productsDB) > limit
	if hasNextPage {
		productsDB = productsDB[:limit]
	}

	edges := make([]model.ProductEdge, len(productsDB))
	for i, prod := range productsDB {
		// For each product, we need to fetch the complete product information
		// including variants, attributes, and images
		productDetails, err := r.Repository.GetProduct(ctx, db.GetProductParams{
			ProductID: prod.ProductID,
			ShopID:    shopID,
		})

		if err != nil {
			return nil, fmt.Errorf("failed to fetch product details for product %d: %w", prod.ProductID, err)
		}

		// Convert the product to a GraphQL model
		product := &model.Product{
			ID:          strconv.FormatInt(prod.ProductID, 10),
			ProductID:   int(prod.ProductID),
			Title:       prod.Title,
			Description: prod.Description,
			Slug:        productDetails.Slug,
			CreatedAt:   prod.CreatedAt.Time,
			UpdatedAt:   prod.UpdatedAt.Time,
			Attributes:  []model.ProductAttribute{},
			Variants:    []model.ProductVariant{},
			Images:      []model.Image{},
		}

		// Parse attributes from JSON
		var attributes []model.ProductAttribute
		if err := json.Unmarshal(productDetails.Attributes, &attributes); err != nil {
			return nil, fmt.Errorf("failed to unmarshal attributes: %w", err)
		}
		product.Attributes = attributes

		// Parse variants from JSON
		var variants []model.ProductVariant
		if err := json.Unmarshal(productDetails.Variants, &variants); err != nil {
			return nil, fmt.Errorf("failed to unmarshal variants: %w", err)
		}

		// Set IDs for variants and find default variant
		var defaultVariant *model.ProductVariant
		for i := range variants {
			variants[i].ID = EncodeIntID("ProductVariant", int64(variants[i].VariationID))
			if variants[i].IsDefault {
				defaultVar := variants[i]
				defaultVariant = &defaultVar
			}
		}

		product.Variants = variants
		product.DefaultVariant = defaultVariant

		// Parse images from JSON
		var images []model.Image
		if err := json.Unmarshal(productDetails.Images, &images); err != nil {
			return nil, fmt.Errorf("failed to unmarshal images: %w", err)
		}
		product.Images = images

		relayID := EncodeIntID("Product", prod.ProductID)
		edges[i] = model.ProductEdge{Cursor: relayID, Node: product}
	}

	var startCursor, endCursor string
	if len(productsDB) > 0 {
		startCursor = EncodeIntID("Product", productsDB[0].ProductID)
		endCursor = EncodeIntID("Product", productsDB[len(productsDB)-1].ProductID)
	}

	// Return the connection
	return &model.ProductConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNextPage,
			StartCursor: startCursor,
			EndCursor:   endCursor,
		},
		TotalCount: len(productsDB),
	}, nil
}

// Images is the resolver for the images field.
func (r *categoryResolver) Images(ctx context.Context, obj *model.Category) (*model.CategoryImages, error) {
	panic(fmt.Errorf("not implemented: Images - images"))
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context, first *int, after *string) (*model.CategoryConnection, error) {
	shopID := ctx.Value("shop_id").(int64)
	limit := 20
	if first != nil {
		limit = *first
	}
	afterID := int64(0)
	if after != nil {
		decodedType, id, err := decodeRelayID(*after)
		if err != nil {
			return nil, fmt.Errorf("invalid after cursor: %w", err)
		}
		if decodedType != "Category" {
			return nil, fmt.Errorf("expected after cursor type 'Category', got '%s'", decodedType)
		}
		if id != nil {
			afterID = *id
		}
	}
	categoriesDB, err := r.Repository.GetCategories(ctx, db.GetCategoriesParams{ShopID: shopID, After: afterID, Limit: int32(limit) + 1})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch categories: %w", err)
	}
	hasNextPage := len(categoriesDB) > limit
	if hasNextPage {
		categoriesDB = categoriesDB[:limit]
	}
	edges := make([]model.CategoryEdge, len(categoriesDB))
	for i, cat := range categoriesDB {
		relayID := EncodeIntID("Category", cat.CategoryID)
		edges[i] = model.CategoryEdge{Cursor: relayID, Node: &model.Category{
			ID:          strconv.FormatInt(cat.CategoryID, 10),
			Slug:        cat.Slug,
			Title:       cat.Title,
			Description: cat.Description,
		}}
	}
	var startCursor, endCursor string
	if len(categoriesDB) > 0 {
		startCursor = EncodeIntID("Category", categoriesDB[0].CategoryID)
		endCursor = EncodeIntID("Category", categoriesDB[len(categoriesDB)-1].CategoryID)
	}

	pageInfo := &model.PageInfo{
		HasNextPage: hasNextPage,
		StartCursor: startCursor,
		EndCursor:   endCursor,
	}

	// Return the CategoryConnection result
	return &model.CategoryConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: len(categoriesDB),
	}, nil
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, id string) (*model.Category, error) {
	// Extract category ID
	decodedType, idPtr, err := decodeRelayID(id)
	if err != nil || decodedType != "Category" {
		return nil, errors.New("invalid category ID")
	}

	shopID := ctx.Value("shop_id").(int64)
	categoryID := *idPtr
	cat, err := r.Repository.GetCategory(ctx, db.GetCategoryParams{ShopID: shopID, CategoryID: categoryID})
	if err != nil {
		return nil, errors.New("could not find category")
	}
	return &model.Category{
		ID:          strconv.FormatInt(cat.CategoryID, 10),
		Slug:        cat.Slug,
		Title:       cat.Title,
		Description: cat.Description,
	}, nil
}

// Category returns generated.CategoryResolver implementation.
func (r *Resolver) Category() generated.CategoryResolver { return &categoryResolver{r} }

type categoryResolver struct{ *Resolver }
