package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"

	pgx "github.com/jackc/pgx/v5"
	"github.com/petrejonn/naytife/internal/db"
	"github.com/petrejonn/naytife/internal/gql/public/generated"
	"github.com/petrejonn/naytife/internal/gql/public/model"
)

// Shop is the resolver for the shop field.
func (r *queryResolver) Shop(ctx context.Context) (*model.Shop, error) {
	shopID := ctx.Value("shop_id").(int64)
	shop, err := r.Repository.GetShop(ctx, shopID)
	if err != nil {
		return nil, err
	}

	// Initialize an empty slice to prevent nil
	seoKeywords := []string{}
	if shop.SeoKeywords != nil {
		seoKeywords = shop.SeoKeywords
	}

	return &model.Shop{
		ID:             strconv.FormatInt(shop.ShopID, 10),
		Title:          shop.Title,
		CurrencyCode:   shop.CurrencyCode,
		About:          shop.About,
		SeoDescription: shop.SeoDescription,
		SeoTitle:       shop.SeoTitle,
		WhatsAppNumber: shop.WhatsappPhoneNumber,
		WhatsAppLink:   shop.WhatsappLink,
		FacebookLink:   shop.FacebookLink,
		InstagramLink:  shop.InstagramLink,
		ContactEmail:   &shop.Email,
		ContactPhone:   shop.PhoneNumber,
		Address: &model.ShopAddress{
			Address: safeStringDereference(shop.Address),
		},
		SeoKeywords: seoKeywords,
	}, nil
}

// ID is the resolver for the id field.
func (r *shopResolver) ID(ctx context.Context, obj *model.Shop) (string, error) {
	return encodeRelayID("Shop", obj.ID), nil
}

// Categories is the resolver for the categories field.
func (r *shopResolver) Categories(ctx context.Context, obj *model.Shop, first *int, after *string) (*model.CategoryConnection, error) {
	shopID := ctx.Value("shop_id").(int64)
	limit := 20
	if first != nil {
		limit = *first
	}
	afterID := int64(0)
	if after != nil {
		decodedType, id, err := decodeRelayID(*after)
		if err != nil {
			return nil, fmt.Errorf("invalid after cursor: %w", err)
		}
		if decodedType != "Category" {
			return nil, fmt.Errorf("expected after cursor type 'Category', got '%s'", decodedType)
		}
		if id != nil {
			afterID = *id
		}
	}
	categoriesDB, err := r.Repository.GetCategories(ctx, db.GetCategoriesParams{ShopID: shopID, After: afterID, Limit: int32(limit) + 1})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch categories: %w", err)
	}
	hasNextPage := len(categoriesDB) > limit
	if hasNextPage {
		categoriesDB = categoriesDB[:limit]
	}
	edges := make([]model.CategoryEdge, len(categoriesDB))
	for i, cat := range categoriesDB {
		relayID := encodeRelayID("Category", strconv.FormatInt(cat.CategoryID, 10))
		edges[i] = model.CategoryEdge{Cursor: relayID, Node: &model.Category{
			ID:          strconv.FormatInt(cat.CategoryID, 10),
			Slug:        cat.Slug,
			Title:       cat.Title,
			Description: cat.Description,
		}}
	}
	var startCursor, endCursor *string
	if len(categoriesDB) > 0 {
		firstCursor := encodeRelayID("Category", strconv.FormatInt(categoriesDB[0].CategoryID, 10))
		lastCursor := encodeRelayID("Category", strconv.FormatInt(categoriesDB[len(categoriesDB)-1].CategoryID, 10))
		startCursor, endCursor = &firstCursor, &lastCursor
	}

	pageInfo := &model.PageInfo{
		HasNextPage: hasNextPage,
		StartCursor: safeStringDereference(startCursor),
		EndCursor:   safeStringDereference(endCursor),
	}

	// Return the CategoryConnection result
	return &model.CategoryConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: len(categoriesDB),
	}, nil
}

// Images is the resolver for the images field.
func (r *shopResolver) Images(ctx context.Context, obj *model.Shop) (*model.ShopImages, error) {
	shopID := ctx.Value("shop_id").(int64)

	shopImages, err := r.Repository.GetShopImages(ctx, shopID)
	if err != nil {
		// Only return error if it's not "no rows"
		if errors.Is(err, pgx.ErrNoRows) {
			// No images found, return nil (or you could return &model.ShopImages{} for empty object)
			return &model.ShopImages{}, nil
		}
		return nil, fmt.Errorf("failed to fetch shop images: %w", err)
	}

	// Map DB shop images to GraphQL model
	var siteLogo, siteLogoDark, favicon, banner, bannerDark, coverImage, coverImageDark *model.Image

	if shopImages.LogoUrl != nil {
		siteLogo = &model.Image{
			URL: *shopImages.LogoUrl,
		}
	}

	if shopImages.LogoUrlDark != nil {
		siteLogoDark = &model.Image{
			URL: *shopImages.LogoUrlDark,
		}
	}

	if shopImages.FaviconUrl != nil {
		favicon = &model.Image{
			URL: *shopImages.FaviconUrl,
		}
	}

	if shopImages.BannerUrl != nil {
		banner = &model.Image{
			URL: *shopImages.BannerUrl,
		}
	}

	if shopImages.BannerUrlDark != nil {
		bannerDark = &model.Image{
			URL: *shopImages.BannerUrlDark,
		}
	}

	if shopImages.CoverImageUrl != nil {
		coverImage = &model.Image{
			URL: *shopImages.CoverImageUrl,
		}
	}

	if shopImages.CoverImageUrlDark != nil {
		coverImageDark = &model.Image{
			URL: *shopImages.CoverImageUrlDark,
		}
	}

	return &model.ShopImages{
		SiteLogo:       siteLogo,
		SiteLogoDark:   siteLogoDark,
		Favicon:        favicon,
		Banner:         banner,
		BannerDark:     bannerDark,
		CoverImage:     coverImage,
		CoverImageDark: coverImageDark,
	}, nil
}

// PaymentMethods is the resolver for the paymentMethods field.
func (r *shopResolver) PaymentMethods(ctx context.Context, obj *model.Shop) ([]model.PaymentMethodInfo, error) {
	shopID := ctx.Value("shop_id").(int64)

	// Get payment methods from database
	paymentMethods, err := r.Repository.GetShopPaymentMethods(ctx, shopID)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL model
	result := make([]model.PaymentMethodInfo, 0, len(paymentMethods))
	for _, pm := range paymentMethods {
		var config map[string]interface{}
		if len(pm.Attributes) > 0 {
			if err := json.Unmarshal(pm.Attributes, &config); err != nil {
				continue // Skip invalid configurations
			}
		}

		provider := string(pm.MethodType)
		name := strings.Title(provider)

		var (
			publishableKey, clientID, publicKey, publicKeyFlutterwave    *string
			testMode, sandboxMode, testModePaystack, testModeFlutterwave *bool
		)

		switch provider {
		case "stripe":
			if v, ok := config["publishable_key"].(string); ok {
				publishableKey = &v
			}
			if v, ok := config["test_mode"].(bool); ok {
				testMode = &v
			}
		case "paypal":
			if v, ok := config["client_id"].(string); ok {
				clientID = &v
			}
			if v, ok := config["sandbox_mode"].(bool); ok {
				sandboxMode = &v
			}
		case "paystack":
			if v, ok := config["public_key"].(string); ok {
				publicKey = &v
			}
			if v, ok := config["test_mode_paystack"].(bool); ok {
				testModePaystack = &v
			}
		case "flutterwave":
			if v, ok := config["public_key_flutterwave"].(string); ok {
				publicKeyFlutterwave = &v
			}
			if v, ok := config["test_mode_flutterwave"].(bool); ok {
				testModeFlutterwave = &v
			}
		}

		result = append(result, model.PaymentMethodInfo{
			ID:       string(pm.MethodType),
			Name:     name,
			Provider: provider,
			Enabled:  pm.IsEnabled,
			Config: &model.PaymentMethodConfig{
				PublishableKey:       publishableKey,
				TestMode:             testMode,
				ClientID:             clientID,
				SandboxMode:          sandboxMode,
				PublicKey:            publicKey,
				TestModePaystack:     testModePaystack,
				PublicKeyFlutterwave: publicKeyFlutterwave,
				TestModeFlutterwave:  testModeFlutterwave,
			},
		})
	}

	return result, nil
}

// Shop returns generated.ShopResolver implementation.
func (r *Resolver) Shop() generated.ShopResolver { return &shopResolver{r} }

type shopResolver struct{ *Resolver }
