package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.75

import (
	"context"
	"errors"
	"fmt"
	"math/big"
	"strings"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/petrejonn/naytife/internal/db"
	"github.com/petrejonn/naytife/internal/gql/public/generated"
	"github.com/petrejonn/naytife/internal/gql/public/model"
)

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.CreateOrderInput) (*model.CreateOrderPayload, error) {
	// Extract shop ID from context
	shopID, ok := ctx.Value("shop_id").(int64)
	if !ok {
		return &model.CreateOrderPayload{
			Errors: []model.UserError{&model.CategoryNotFoundError{
				Message: "Shop ID not found in context",
				Code:    model.ErrorCodeServerErrorInternal,
			}},
		}, nil
	}

	// Calculate the total amount from items
	var total float64
	for _, item := range input.Items {
		total += float64(item.Quantity) * item.Price
	}

	// Apply discounts, shipping costs, and taxes
	discount := 0.0
	if input.Discount != nil {
		discount = *input.Discount
	}

	shippingCost := 0.0
	if input.ShippingCost != nil {
		shippingCost = *input.ShippingCost
	}

	tax := 0.0
	if input.Tax != nil {
		tax = *input.Tax
	}

	// Calculate final amount
	finalAmount := total - discount + shippingCost + tax

	// Extract or assign user ID for the order (optional for anonymous purchases)
	var pgUserID pgtype.UUID
	var username string
	var customerName string
	var customerEmail, customerPhone *string

	if input.CustomerID != nil {
		// Registered user
		relayID, err := DecodeRelayID(*input.CustomerID)
		if err != nil || relayID.Type != "Customer" || relayID.UUID == nil {
			return &model.CreateOrderPayload{
				Errors: []model.UserError{&model.CategoryNotFoundError{
					Message: "Invalid customer ID",
					Code:    model.ErrorCodeValidationInvalidInput,
				}},
			}, nil
		}
		pgUserID = GetPgUUID(*relayID.UUID)
		username = "Customer" // TODO: Get actual username from user service
		customerName = username
	} else {
		// Anonymous order
		pgUserID = pgtype.UUID{Valid: false}

		// Validate fullName (required)
		if input.FullName == nil || *input.FullName == "" {
			return &model.CreateOrderPayload{
				Errors: []model.UserError{&model.CategoryNotFoundError{
					Message: "Full name is required for anonymous orders",
					Code:    model.ErrorCodeValidationInvalidInput,
				}},
			}, nil
		}
		username = *input.FullName
		customerName = *input.FullName

		// Validate email (required)
		if input.Email == nil || *input.Email == "" {
			return &model.CreateOrderPayload{
				Errors: []model.UserError{&model.CategoryNotFoundError{
					Message: "Email is required for anonymous orders",
					Code:    model.ErrorCodeValidationInvalidInput,
				}},
			}, nil
		}

		// Simple email validation
		if !strings.Contains(*input.Email, "@") {
			return &model.CreateOrderPayload{
				Errors: []model.UserError{&model.CategoryNotFoundError{
					Message: "Invalid email format",
					Code:    model.ErrorCodeValidationInvalidInput,
				}},
			}, nil
		}
		customerEmail = input.Email

		// Validate phone number (required)
		if input.PhoneNumber == nil || *input.PhoneNumber == "" {
			return &model.CreateOrderPayload{
				Errors: []model.UserError{&model.CategoryNotFoundError{
					Message: "Phone number is required for anonymous orders",
					Code:    model.ErrorCodeValidationInvalidInput,
				}},
			}, nil
		}

		// Basic phone validation - could be enhanced with regex pattern matching
		if len(*input.PhoneNumber) < 6 {
			return &model.CreateOrderPayload{
				Errors: []model.UserError{&model.CategoryNotFoundError{
					Message: "Phone number is too short",
					Code:    model.ErrorCodeValidationInvalidInput,
				}},
			}, nil
		}
		customerPhone = input.PhoneNumber
	}

	// Create numeric types for monetary values
	amountNumeric := pgtype.Numeric{
		Int:   big.NewInt(int64(finalAmount * 100)),
		Exp:   0,
		Valid: true,
	}

	discountNumeric := pgtype.Numeric{
		Int:   big.NewInt(int64(discount * 100)),
		Exp:   0,
		Valid: true,
	}

	shippingCostNumeric := pgtype.Numeric{
		Int:   big.NewInt(int64(shippingCost * 100)),
		Exp:   0,
		Valid: true,
	}

	taxNumeric := pgtype.Numeric{
		Int:   big.NewInt(int64(tax * 100)),
		Exp:   0,
		Valid: true,
	}

	// Use the original shipping address without appending contact info
	shippingAddress := input.ShippingAddress

	// Create the order in the database
	orderParams := db.CreateOrderParams{
		Status:          db.OrderStatusType(strings.ToLower(string(model.OrderStatusTypePending))),
		Amount:          amountNumeric,
		Discount:        discountNumeric,
		ShippingCost:    shippingCostNumeric,
		Tax:             taxNumeric,
		ShippingAddress: shippingAddress,
		PaymentMethod:   db.PaymentMethodType(strings.ToLower(string(input.PaymentMethod))),
		PaymentStatus:   db.PaymentStatusType(strings.ToLower(string(model.PaymentStatusTypePending))),
		ShippingMethod:  input.ShippingMethod,
		ShippingStatus:  db.ShippingStatusType(strings.ToLower(string(model.ShippingStatusTypePending))),
		TransactionID:   nil, // Will be updated later after payment
		Username:        username,
		ShopCustomerID:  pgUserID,
		ShopID:          shopID,
		CustomerName:    customerName,
		CustomerEmail:   customerEmail,
		CustomerPhone:   customerPhone,
	}

	// Create the order
	orderDB, err := r.Repository.CreateOrder(ctx, orderParams)
	if err != nil {
		return &model.CreateOrderPayload{
			Errors: []model.UserError{&model.CategoryNotFoundError{
				Message: "Failed to create order: " + err.Error(),
				Code:    model.ErrorCodeServerErrorInternal,
			}},
		}, nil
	}

	// Create order items
	orderItems := make([]model.OrderItem, 0, len(input.Items))
	for _, itemInput := range input.Items {
		// Extract product variation ID
		productVariationID, err := DecodeRelayID(itemInput.ProductVariationID)
		if err != nil || productVariationID.Type != "ProductVariant" || productVariationID.IntID == nil {
			return &model.CreateOrderPayload{
				Errors: []model.UserError{&model.CategoryNotFoundError{
					Message: "Invalid product variation ID",
					Code:    model.ErrorCodeValidationInvalidInput,
				}},
			}, nil
		}

		// Create price numeric
		priceNumeric := pgtype.Numeric{
			Int:   big.NewInt(int64(itemInput.Price * 100)),
			Exp:   0,
			Valid: true,
		}

		// Create the order item
		itemParams := db.CreateOrderItemParams{
			Quantity:           int64(itemInput.Quantity),
			Price:              priceNumeric,
			ProductVariationID: *productVariationID.IntID,
			OrderID:            orderDB.OrderID,
			ShopID:             shopID,
		}

		orderItemDB, err := r.Repository.CreateOrderItem(ctx, itemParams)
		if err != nil {
			return &model.CreateOrderPayload{
				Errors: []model.UserError{&model.CategoryNotFoundError{
					Message: "Failed to create order item: " + err.Error(),
					Code:    model.ErrorCodeServerErrorInternal,
				}},
			}, nil
		}

		// Convert to GraphQL model
		orderItems = append(orderItems, model.OrderItem{
			ID:                 EncodeIntID("OrderItem", orderItemDB.OrderItemID),
			OrderItemID:        int(orderItemDB.OrderItemID),
			Quantity:           int(orderItemDB.Quantity),
			Price:              numericToFloat64(&orderItemDB.Price) / 100.0,
			ProductVariationID: itemInput.ProductVariationID,
		})
	}

	// Convert to GraphQL model
	order := &model.Order{
		ID:              EncodeIntID("Order", orderDB.OrderID),
		OrderID:         int(orderDB.OrderID),
		Status:          model.OrderStatusType(strings.ToUpper(string(orderDB.Status))),
		CreatedAt:       orderDB.CreatedAt.Time,
		UpdatedAt:       orderDB.UpdatedAt.Time,
		CustomerID:      input.CustomerID,
		Amount:          numericToFloat64(&orderDB.Amount) / 100.0,
		Discount:        numericToFloat64(&orderDB.Discount) / 100.0,
		ShippingCost:    numericToFloat64(&orderDB.ShippingCost) / 100.0,
		Tax:             numericToFloat64(&orderDB.Tax) / 100.0,
		ShippingAddress: orderDB.ShippingAddress,
		PaymentMethod:   model.PaymentMethodType(strings.ToUpper(string(orderDB.PaymentMethod))),
		PaymentStatus:   model.PaymentStatusType(strings.ToUpper(string(orderDB.PaymentStatus))),
		ShippingMethod:  orderDB.ShippingMethod,
		ShippingStatus:  model.ShippingStatusType(strings.ToUpper(string(orderDB.ShippingStatus))),
		TransactionID:   orderDB.TransactionID,
		Username:        orderDB.Username,
		ShopID:          EncodeIntID("Shop", shopID),
		Items:           orderItems,
		CustomerName:    orderDB.CustomerName,
		CustomerEmail:   orderDB.CustomerEmail,
		CustomerPhone:   orderDB.CustomerPhone,
	}

	return &model.CreateOrderPayload{
		Order:  order,
		Errors: nil,
	}, nil
}

// UpdateOrderStatus is the resolver for the updateOrderStatus field.
func (r *mutationResolver) UpdateOrderStatus(ctx context.Context, input model.UpdateOrderStatusInput) (*model.UpdateOrderStatusPayload, error) {
	// Get shop ID from context
	shopID, ok := ctx.Value("shop_id").(int64)
	if !ok {
		return &model.UpdateOrderStatusPayload{
			Errors: []model.UserError{&model.CategoryNotFoundError{
				Message: "Shop ID not found in context",
				Code:    model.ErrorCodeServerErrorInternal,
			}},
		}, nil
	}

	// Extract order ID
	orderID, err := DecodeRelayID(input.OrderID)
	if err != nil || orderID.Type != "Order" || orderID.IntID == nil {
		return &model.UpdateOrderStatusPayload{
			Errors: []model.UserError{&model.CategoryNotFoundError{
				Message: "Invalid order ID",
				Code:    model.ErrorCodeValidationInvalidInput,
			}},
		}, nil
	}

	// Get the current order to validate it exists
	orderDB, err := r.Repository.GetOrder(ctx, db.GetOrderParams{
		OrderID: *orderID.IntID,
		ShopID:  shopID,
	})
	if err != nil {
		return &model.UpdateOrderStatusPayload{
			Errors: []model.UserError{&model.CategoryNotFoundError{
				Message: "Order not found",
				Code:    model.ErrorCodeNotFoundShop,
			}},
		}, nil
	}

	// Update the order status
	updateParams := db.UpdateOrderParams{
		Status:          db.OrderStatusType(strings.ToLower(string(input.Status))),
		Amount:          orderDB.Amount,
		Discount:        orderDB.Discount,
		ShippingCost:    orderDB.ShippingCost,
		Tax:             orderDB.Tax,
		ShippingAddress: orderDB.ShippingAddress,
		PaymentMethod:   orderDB.PaymentMethod,
		PaymentStatus:   orderDB.PaymentStatus,
		ShippingMethod:  orderDB.ShippingMethod,
		ShippingStatus:  orderDB.ShippingStatus,
		TransactionID:   orderDB.TransactionID,
		Username:        orderDB.Username,
		OrderID:         orderDB.OrderID,
		ShopID:          shopID,
	}

	// Update the order in the database
	err = r.Repository.UpdateOrder(ctx, updateParams)
	if err != nil {
		return &model.UpdateOrderStatusPayload{
			Errors: []model.UserError{&model.CategoryNotFoundError{
				Message: "Failed to update order status: " + err.Error(),
				Code:    model.ErrorCodeServerErrorInternal,
			}},
		}, nil
	}

	// Fetch the updated order
	updatedOrder, err := r.Repository.GetOrder(ctx, db.GetOrderParams{
		OrderID: *orderID.IntID,
		ShopID:  shopID,
	})
	if err != nil {
		return &model.UpdateOrderStatusPayload{
			Errors: []model.UserError{&model.CategoryNotFoundError{
				Message: "Failed to fetch updated order",
				Code:    model.ErrorCodeServerErrorInternal,
			}},
		}, nil
	}

	// Get order items
	orderItemsDB, err := r.Repository.GetOrderItemsByOrder(ctx, db.GetOrderItemsByOrderParams{
		OrderID: updatedOrder.OrderID,
		ShopID:  shopID,
	})
	if err != nil {
		return &model.UpdateOrderStatusPayload{
			Errors: []model.UserError{&model.CategoryNotFoundError{
				Message: "Failed to fetch order items",
				Code:    model.ErrorCodeServerErrorInternal,
			}},
		}, nil
	}

	// Convert order items to GraphQL model
	orderItems := make([]model.OrderItem, 0, len(orderItemsDB))
	for _, item := range orderItemsDB {
		orderItems = append(orderItems, model.OrderItem{
			ID:                 EncodeIntID("OrderItem", item.OrderItemID),
			OrderItemID:        int(item.OrderItemID),
			Quantity:           int(item.Quantity),
			Price:              numericToFloat64(&item.Price) / 100.0,
			ProductVariationID: EncodeIntID("ProductVariant", item.ProductVariationID),
		})
	}

	// Create customer ID
	var customerID *string
	if pgUUID := ParsePgUUID(updatedOrder.ShopCustomerID); pgUUID != nil {
		idStr := EncodeUUIDID("Customer", *pgUUID)
		customerID = &idStr
	}

	// Convert to GraphQL model
	order := &model.Order{
		ID:              EncodeIntID("Order", updatedOrder.OrderID),
		OrderID:         int(updatedOrder.OrderID),
		Status:          model.OrderStatusType(strings.ToUpper(string(updatedOrder.Status))),
		CreatedAt:       updatedOrder.CreatedAt.Time,
		UpdatedAt:       updatedOrder.UpdatedAt.Time,
		CustomerID:      customerID,
		Amount:          numericToFloat64(&updatedOrder.Amount) / 100.0,
		Discount:        numericToFloat64(&updatedOrder.Discount) / 100.0,
		ShippingCost:    numericToFloat64(&updatedOrder.ShippingCost) / 100.0,
		Tax:             numericToFloat64(&updatedOrder.Tax) / 100.0,
		ShippingAddress: updatedOrder.ShippingAddress,
		PaymentMethod:   model.PaymentMethodType(strings.ToUpper(string(updatedOrder.PaymentMethod))),
		PaymentStatus:   model.PaymentStatusType(strings.ToUpper(string(updatedOrder.PaymentStatus))),
		ShippingMethod:  updatedOrder.ShippingMethod,
		ShippingStatus:  model.ShippingStatusType(strings.ToUpper(string(updatedOrder.ShippingStatus))),
		TransactionID:   updatedOrder.TransactionID,
		Username:        updatedOrder.Username,
		ShopID:          EncodeIntID("Shop", updatedOrder.ShopID),
		Items:           orderItems,
		CustomerName:    updatedOrder.CustomerName,
		CustomerEmail:   updatedOrder.CustomerEmail,
		CustomerPhone:   updatedOrder.CustomerPhone,
	}

	return &model.UpdateOrderStatusPayload{
		Order:  order,
		Errors: nil,
	}, nil
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context, first *int, after *string) (*model.OrderConnection, error) {
	// Get shop ID from context
	shopID, ok := ctx.Value("shop_id").(int64)
	if !ok {
		return nil, errors.New("shop ID not found in context")
	}

	// Set default limit
	limit := 20
	if first != nil {
		limit = *first
	}

	// Parse the after cursor if provided
	var afterID int64
	if after != nil && *after != "" {
		decodedID, err := DecodeRelayID(*after)
		if err != nil || decodedID.Type != "Order" || decodedID.IntID == nil {
			return nil, errors.New("invalid cursor format")
		}
		afterID = *decodedID.IntID
	}

	// Fetch orders from database
	ordersDB, err := r.Repository.ListOrders(ctx, db.ListOrdersParams{
		ShopID: shopID,
		Limit:  int32(limit + 1), // Fetch one extra to check for hasNextPage
		Offset: int32(afterID),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch orders: %w", err)
	}

	// Check if there are more pages
	hasNextPage := len(ordersDB) > limit
	if hasNextPage {
		ordersDB = ordersDB[:limit] // Remove the extra item
	}

	// Build the edges
	edges := make([]model.OrderEdge, 0, len(ordersDB))
	for _, orderDB := range ordersDB {
		// Fetch order items for this order
		orderItemsDB, err := r.Repository.GetOrderItemsByOrder(ctx, db.GetOrderItemsByOrderParams{
			OrderID: orderDB.OrderID,
			ShopID:  shopID,
		})
		if err != nil {
			return nil, fmt.Errorf("failed to fetch order items: %w", err)
		}

		// Convert order items to GraphQL model
		orderItems := make([]model.OrderItem, 0, len(orderItemsDB))
		for _, item := range orderItemsDB {
			orderItems = append(orderItems, model.OrderItem{
				ID:                 EncodeIntID("OrderItem", item.OrderItemID),
				OrderItemID:        int(item.OrderItemID),
				Quantity:           int(item.Quantity),
				Price:              numericToFloat64(&item.Price) / 100.0,
				ProductVariationID: EncodeIntID("ProductVariant", item.ProductVariationID),
			})
		}

		// Generate customer ID
		var customerID *string
		if pgUUID := ParsePgUUID(orderDB.ShopCustomerID); pgUUID != nil {
			idStr := EncodeUUIDID("Customer", *pgUUID)
			customerID = &idStr
		}

		// Create the order edge
		order := &model.Order{
			ID:              EncodeIntID("Order", orderDB.OrderID),
			OrderID:         int(orderDB.OrderID),
			Status:          model.OrderStatusType(strings.ToUpper(string(orderDB.Status))),
			CreatedAt:       orderDB.CreatedAt.Time,
			UpdatedAt:       orderDB.UpdatedAt.Time,
			CustomerID:      customerID,
			Amount:          numericToFloat64(&orderDB.Amount) / 100.0,
			Discount:        numericToFloat64(&orderDB.Discount) / 100.0,
			ShippingCost:    numericToFloat64(&orderDB.ShippingCost) / 100.0,
			Tax:             numericToFloat64(&orderDB.Tax) / 100.0,
			ShippingAddress: orderDB.ShippingAddress,
			PaymentMethod:   model.PaymentMethodType(strings.ToUpper(string(orderDB.PaymentMethod))),
			PaymentStatus:   model.PaymentStatusType(strings.ToUpper(string(orderDB.PaymentStatus))),
			ShippingMethod:  orderDB.ShippingMethod,
			ShippingStatus:  model.ShippingStatusType(strings.ToUpper(string(orderDB.ShippingStatus))),
			TransactionID:   orderDB.TransactionID,
			Username:        orderDB.Username,
			ShopID:          EncodeIntID("Shop", orderDB.ShopID),
			Items:           orderItems,
			CustomerName:    orderDB.CustomerName,
			CustomerEmail:   orderDB.CustomerEmail,
			CustomerPhone:   orderDB.CustomerPhone,
		}

		edges = append(edges, model.OrderEdge{
			Cursor: EncodeIntID("Order", orderDB.OrderID),
			Node:   order,
		})
	}

	// Create page info
	var startCursor, endCursor *string
	if len(edges) > 0 {
		startCursor = &edges[0].Cursor
		endCursor = &edges[len(edges)-1].Cursor
	}

	pageInfo := &model.PageInfo{
		HasNextPage: hasNextPage,
		StartCursor: stringDereference(startCursor),
		EndCursor:   stringDereference(endCursor),
	}

	return &model.OrderConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: len(edges),
	}, nil
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id string) (*model.Order, error) {
	// Get shop ID from context
	shopID, ok := ctx.Value("shop_id").(int64)
	if !ok {
		return nil, errors.New("shop ID not found in context")
	}

	// Extract order ID
	orderID, err := DecodeRelayID(id)
	if err != nil || orderID.Type != "Order" || orderID.IntID == nil {
		return nil, errors.New("invalid order ID format")
	}

	// Fetch the order from database
	orderDB, err := r.Repository.GetOrder(ctx, db.GetOrderParams{
		OrderID: *orderID.IntID,
		ShopID:  shopID,
	})
	if err != nil {
		return nil, fmt.Errorf("order not found: %w", err)
	}

	// Fetch order items
	orderItemsDB, err := r.Repository.GetOrderItemsByOrder(ctx, db.GetOrderItemsByOrderParams{
		OrderID: orderDB.OrderID,
		ShopID:  shopID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch order items: %w", err)
	}

	// Convert order items to GraphQL model
	orderItems := make([]model.OrderItem, 0, len(orderItemsDB))
	for _, item := range orderItemsDB {
		orderItems = append(orderItems, model.OrderItem{
			ID:                 EncodeIntID("OrderItem", item.OrderItemID),
			OrderItemID:        int(item.OrderItemID),
			Quantity:           int(item.Quantity),
			Price:              numericToFloat64(&item.Price) / 100.0,
			ProductVariationID: EncodeIntID("ProductVariant", item.ProductVariationID),
		})
	}

	// Generate customer ID
	var customerID *string
	if pgUUID := ParsePgUUID(orderDB.ShopCustomerID); pgUUID != nil {
		idStr := EncodeUUIDID("Customer", *pgUUID)
		customerID = &idStr
	}

	// Return the order with its items
	return &model.Order{
		ID:              EncodeIntID("Order", orderDB.OrderID),
		OrderID:         int(orderDB.OrderID),
		Status:          model.OrderStatusType(strings.ToUpper(string(orderDB.Status))),
		CreatedAt:       orderDB.CreatedAt.Time,
		UpdatedAt:       orderDB.UpdatedAt.Time,
		CustomerID:      customerID,
		Amount:          numericToFloat64(&orderDB.Amount) / 100.0,
		Discount:        numericToFloat64(&orderDB.Discount) / 100.0,
		ShippingCost:    numericToFloat64(&orderDB.ShippingCost) / 100.0,
		Tax:             numericToFloat64(&orderDB.Tax) / 100.0,
		ShippingAddress: orderDB.ShippingAddress,
		PaymentMethod:   model.PaymentMethodType(strings.ToUpper(string(orderDB.PaymentMethod))),
		PaymentStatus:   model.PaymentStatusType(strings.ToUpper(string(orderDB.PaymentStatus))),
		ShippingMethod:  orderDB.ShippingMethod,
		ShippingStatus:  model.ShippingStatusType(strings.ToUpper(string(orderDB.ShippingStatus))),
		TransactionID:   orderDB.TransactionID,
		Username:        orderDB.Username,
		ShopID:          EncodeIntID("Shop", orderDB.ShopID),
		Items:           orderItems,
		CustomerName:    orderDB.CustomerName,
		CustomerEmail:   orderDB.CustomerEmail,
		CustomerPhone:   orderDB.CustomerPhone,
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
