"""
The @defer directive may be specified on a fragment spread to imply de-prioritization, that causes the fragment to be omitted in the initial response, and delivered as a subsequent response afterward. A query with @defer directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred delivered in a subsequent response. @include and @skip take precedence over @defer.
"""
directive @defer(if: Boolean = true, label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

type AllowedCategoryAttributes {
  dataType: ProductAttributeDataType!
  title: String!
}

type AllowedProductAttributes {
  dataType: ProductAttributeDataType!
  title: String!
}

type Category implements Node {
  allowedAttributes: [AllowedCategoryAttributes!]!
  children: [Category!]
  createdAt: DateTime!
  description: String
  id: ID!
  images: CategoryImages
  products(after: ID, first: Int = 20): ProductConnection
  slug: String!
  title: String!
  updatedAt: DateTime!
}

type CategoryConnection {
  edges: [CategoryEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CategoryEdge {
  cursor: String!
  node: Category!
}

type CategoryImages {
  banner: Image!
}

type CategoryNotFoundError implements UserError {
  code: ErrorCode!
  message: String!
  path: [String!]!
}

input CreateCategoryAttributeInput {
  dataType: ProductAttributeDataType!
  title: String!
}

union CreateCategoryAttributePayload = CategoryNotFoundError | CreateCategoryAttributeSuccess

type CreateCategoryAttributeSuccess {
  attributes: [AllowedCategoryAttributes!]!
}

input CreateCategoryInput {
  description: String
  parentID: ID
  title: String!
}

union CreateCategoryPayload = CreateCategorySuccess

type CreateCategorySuccess {
  category: Category
}

input CreateProductAttributeInput {
  dataType: ProductAttributeDataType!
  title: String!
}

union CreateProductAttributePayload = CreateProductAttributeSuccess | ProductNotFoundError

type CreateProductAttributeSuccess {
  attributes: [AllowedProductAttributes!]!
}

input CreateProductInput {
  categoryID: ID!
  description: String!
  title: String!
}

union CreateProductPayload = CategoryNotFoundError | CreateProductSuccess

type CreateProductSuccess {
  product: Product!
}

input CreateProductVariantInput {
  attributes: [ProductAttributeValueInput!]
  availableQuantity: Int!
  price: Float!
  stockStatus: ProductStockStatus!
}

union CreateProductVariantPayload = CreateProductVariantSuccess | ProductNotFoundError

type CreateProductVariantSuccess {
  variants: [ProductVariant!]!
}

input CreateShopInput {
  domain: String!
  title: String!
}

union CreateShopPayload = CreateShopSuccess

type CreateShopSuccess {
  shop: Shop
}

scalar DateTime

union DeleteCategoryAttributePayload = CategoryNotFoundError | DeleteCategoryAttributeSuccess

type DeleteCategoryAttributeSuccess {
  attributes: [AllowedCategoryAttributes!]!
}

union DeleteProductAttributePayload = DeleteProductAttributeSuccess | ProductNotFoundError

type DeleteProductAttributeSuccess {
  attributes: [AllowedProductAttributes!]!
}

enum ErrorCode {
  AUTH_INVALID_TOKEN
  NOT_FOUND_CATEGORY
  NOT_FOUND_SHOP
  RATE_LIMIT_EXCEEDED
  SERVER_ERROR_INTERNAL
  VALIDATION_INVALID_INPUT
}

type Facebook implements SocialMediaContact {
  handle: String
  url: String
}

type Image {
  altText: String
  url: String!
}

input ImageInput {
  altText: String
  url: String!
}

type Instagram implements SocialMediaContact {
  handle: String
  url: String
}

type Mutation {
  createCategory(category: CreateCategoryInput!): CreateCategoryPayload
  createCategoryAttribute(attribute: CreateCategoryAttributeInput!, categoryID: ID!): CreateCategoryAttributePayload
  createProduct(product: CreateProductInput!): CreateProductPayload
  createProductAttribute(attribute: CreateProductAttributeInput!, productID: ID!): CreateProductAttributePayload
  createProductVariant(productID: ID!, variants: [CreateProductVariantInput!]!): CreateProductVariantPayload
  createShop(shop: CreateShopInput!): CreateShopPayload
  deleteCategoryAttribute(attribute: String!, categoryID: ID!): DeleteCategoryAttributePayload
  deleteProductAttribute(attribute: String!, productID: ID!): DeleteProductAttributePayload
  signInUser(input: SignInInput!): SignInUserPayload!
  updateCategory(category: UpdateCategoryInput!, categoryID: ID!): UpdateCategoryPayload
  updateProduct(product: UpdateProductInput!, productID: ID!): UpdateProductPayload
  updateShop(shop: UpdateShopInput!): UpdateShopPayload
  updateShopFacebook(input: UpdateShopFacebookInput!): UpdateShopFacebookPayload!
  updateShopImages(input: UpdateShopImagesInput!): UpdateShopImagesPayload
  updateShopWhatsApp(input: UpdateShopWhatsAppInput!): UpdateShopWhatsAppPayload!
}

interface Node {
  id: ID!
}

type PageInfo {
  endCursor: ID!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: ID!
}

type PhoneNumber {
  e164: String!
}

input PhoneNumberInput {
  e164: String!
}

type Product implements Node {
  allowedAttributes: [AllowedProductAttributes!]!
  createdAt: DateTime!
  defaultVariant: ProductVariant!
  description: String!
  id: ID!
  images: [Image!]!
  status: ProductStatus
  title: String!
  updatedAt: DateTime!
  variants: [ProductVariant!]!
}

type ProductAttribute {
  key: String!
  value: String
}

enum ProductAttributeDataType {
  INTEGER
  STRING
}

type ProductAttributeValue {
  intValue: Int
  stringValue: String
}

input ProductAttributeValueInput {
  key: String!
  value: String!
}

type ProductConnection {
  edges: [ProductEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProductEdge {
  cursor: ID!
  node: Product!
}

type ProductNotFoundError implements UserError {
  code: ErrorCode!
  message: String!
  path: [String!]!
}

enum ProductStatus {
  ARCHIVED
  DRAFT
  PUBLISHED
}

enum ProductStockStatus {
  IN_STOCK
  OUT_OF_STOCK
  PREORDER
}

type ProductVariant implements Node {
  attributes: [ProductAttribute!]!
  availableQuantity: Int!
  createdAt: DateTime!
  description: String!
  id: ID!
  price: Float!
  slug: String!
  stockStatus: ProductStockStatus!
  updatedAt: DateTime!
}

type Query {
  categories(after: ID, first: Int = 20): CategoryConnection
  category(id: ID!): Category
  node(id: ID!): Node
  product(id: ID!): Product
  products(after: ID, first: Int = 20): ProductConnection!
  shop: Shop!
}

type Shop implements Node {
  about: String
  address: ShopAddress!
  categories(after: ID, first: Int = 20): CategoryConnection
  contactEmail: String
  contactPhone: PhoneNumber
  createdAt: DateTime!
  currencyCode: String!
  defaultDomain: String!
  facebook: Facebook!
  id: ID!
  images: ShopImages!
  products(after: ID, first: Int = 20): ProductConnection
  seoDescription: String
  seoKeywords: [String!]!
  seoTitle: String
  shopProductsCategory: String
  status: ShopStatus!
  title: String!
  updatedAt: DateTime!
  whatsApp: WhatsApp!
}

type ShopAddress {
  address: String!
}

input ShopAddressInput {
  address: String!
}

type ShopImages {
  banner: Image
  coverImage: Image
  favicon: Image
  siteLogo: Image
}

type ShopNotFoundError implements UserError {
  code: ErrorCode!
  message: String!
  path: [String!]!
}

enum ShopStatus {
  ARCHIVED
  DRAFT
  PUBLISHED
  SUSPENDED
}

input SignInInput {
  username: String
}

union SignInUserPayload = SignInUserSuccess

type SignInUserSuccess {
  user: User
}

interface SocialMediaContact {
  url: String
}

input UpdateCategoryInput {
  description: String
  parentID: ID
  title: String
}

union UpdateCategoryPayload = CategoryNotFoundError | UpdateCategorySuccess

type UpdateCategorySuccess {
  category: Category!
}

input UpdateProductInput {
  description: String
  title: String
}

union UpdateProductPayload = ProductNotFoundError | UpdateProductSuccess

type UpdateProductSuccess {
  product: Product!
}

input UpdateShopFacebookInput {
  handle: String
  url: String
}

union UpdateShopFacebookPayload = UpdateShopFacebookSuccess

type UpdateShopFacebookSuccess {
  facebook: Facebook!
}

input UpdateShopImagesInput {
  banner: ImageInput
  coverImage: ImageInput
  favicon: ImageInput
  siteLogo: ImageInput
}

union UpdateShopImagesPayload = UpdateShopImagesSuccess

type UpdateShopImagesSuccess {
  images: ShopImages!
}

input UpdateShopInput {
  about: String
  address: ShopAddressInput
  contactEmail: String
  contactPhone: PhoneNumberInput
  currencyCode: String
  seoDescription: String
  seoKeywords: [String!]
  seoTitle: String
  title: String
}

union UpdateShopPayload = UpdateShopSuccess

type UpdateShopSuccess {
  shop: Shop
}

input UpdateShopWhatsAppInput {
  phoneNumber: PhoneNumberInput
  url: String
}

union UpdateShopWhatsAppPayload = UpdateShopWhatsAppSuccess

type UpdateShopWhatsAppSuccess {
  whatsApp: WhatsApp!
}

type User implements Node {
  createdAt: String!
  email: String!
  id: ID!
  lastLogin: String!
  name: String
  profilePictureUrl: String
}

interface UserError {
  code: ErrorCode!
  message: String!
  path: [String!]!
}

type WhatsApp implements SocialMediaContact {
  phoneNumber: PhoneNumber
  url: String
}
